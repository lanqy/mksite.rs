<h1>在 ReasonReact 中创建全局状态</h1>
<p>译自：https://medium.com/@Hehk/creating-global-state-in-reasonreact-f84701c6ab6</p>
<p>默认情况下，ReasonReact 为通过使用 Reducer 组件管理有状态组件提供了一个解决方案。Reducer 组件对于管理整个系统中的小部分状态非常好，但在更大的应用程序中遇到一些严重问题。具有更持久的全局状态，使用减速器体系结构并将状态提升到组件之外将提供两全其美。</p>
<h2>设置一个基本的 Reducer 组件</h2>
<p>ReasonReact 减速器组件是管理 ReasonReact 应用程序中的状态的基本方式。他们通过建立一个 state ，一系列 actions 和一个 reducer 来实现。</p>
<ul>
<li>state：组件的当前状态</li>
<li>action：一组可以修改状态的动作</li>
<li>reducer：一个函数，它需要一个动作和一个状态来计算一个新的状态。</li>
</ul>
<pre><code class="language-ocaml">type state = {count: int};

/* the actions */
type action = 
    | Increment
    | Decrement;

let component = ReasonReact.reducerComponent(&quot;Counter&quot;);

let make = (_children) =&gt; {
    ...component,
    /* the state */
    initialState: () =&gt; {
        count: 0
    },

    /* the reducer */

    reducer: (action, state) =&gt; 
        switch action {
            | Increment =&gt; ReasonReact.Update({count: state.count + 1})
            | Decrement =&gt; ReasonReact.Update({count: state.count - 1})
        },
    render: ({state, send}) =&gt;
        &lt;div&gt;
            &lt;h1&gt; (ReasonReact.string(string_of_int(state.count))) &lt;/h1&gt;
            &lt;button onClick=((_e) =&gt; send(Increment))&gt; (ReasonReact.string(&quot;+&quot;)) &lt;/button&gt;
            &lt;button onClick=((_e) =&gt; send(Decrement))&gt; (ReasonReact.string(&quot;-&quot;)) &lt;/button&gt;
        &lt;/div&gt;
}
</code></pre>
<p>这个组件是一个简单的计数器，它通过reducer组件体系结构进行变异。</p>
<ol>
<li>用户点击“+”按钮，发送增量动作</li>
<li>减速器在动作和当前状态下被触发</li>
<li>Reducer以新状态返回ReasonReact.Update</li>
</ol>
<p>就是这样，（除了背景布线）这个减速器组件是如何经历变异的。</p>
<p>一个更复杂的例子是待办事项列表。</p>
<pre><code class="language-ocaml">type filter = 
    | Completed
    | UnCompleted
    | None;

type item = {
    name: string,
    completed: bool
};

type state = {
    input: string,
    items: list(item),
    filter
};

let initialState = () =&gt; {
    input: &quot;test&quot;,
    items: [{name: &quot;initial item&quot;, completed: true}, {name: &quot;kewl item&quot;, completed: false}],
    filter: None
}

type action = 
    | AddItem(item)
    | RemoveItem(item)
    | ChangeInput(string)
    | ToggleItem(string)
    | ChangeFilter(filter);
    
let reducer = (action, state) =&gt;
    switch action {
        | AddItem(item) =&gt; ReasonReact.Update({...state, items: [item, ...state.items], input: &quot;&quot;})
        | RemoveItem(item) =&gt;
            ReasonReact.Update({...state, items: List.filter((elem: item) =&gt; elem.name != item.name, state.items)})
        | ChangeInput(input) =&gt; ReasonReact.Update({...state, input})
        | ToggleItem(name) =&gt; ReasonReact.Update({
            ...state,
            items: List.map((item) =&gt; name == item.name ? {...item, completed: !item.completed }: item, state.items)
        })
        | ChangeFilter(filter) =&gt; ReasonReact.Update({...state, filter})
    };

let createItem = (~name, ()) =&gt; {name, completed: false};

let component = ReasonReact.reducerComponent(&quot;App&quot;);

let make = (_children) =&gt; {
    ...component,
    render: ({state, send}) =&gt; 
        &lt;div&gt;
            &lt;input value=state.input onChange=((e) =&gt; send(ChangeInput(Obj.magic(e)##target##value))) /&gt;
            &lt;button onClick=((_e) =&gt; send(AddItem(createItem(~name=state.input, ()))))&gt;
                (ReasonReact.string(&quot;add&quot;))s
            &lt;/button&gt;
        &lt;/div&gt;
}

</code></pre>
<p>虽然这个例子中有很多代码，但系统实际上相当简单。所有操作都是 actions，它们通过 reducer 映射到简单的状态更改。如果你感到困惑，我会建议你走进一个动作的生命周期，这些部分应该是有意义的。</p>
<p>我强烈建议您阅读文档，他们会详细解释不同类型的更新以及与 reducer 组件交互的更有趣方式。https://reasonml.github.io/reason-react/docs/en/state-actions-reducer.html</p>
<h2>减速器组件的缺点</h2>
<p>上述示例的最大问题是状态本质上与组件绑定。例如，如果删除组件，则状态将丢失，如果丢失状态，组件将从其初始状态重新启动。在处理路由等问题时，这种短暂的状态成为一个巨大的问题，因为无法在URL更改之间维护您的状态。</p>
<h2>你怎么解决这个问题</h2>
<p>全局状态，通过将状态从这些短暂的组件中移出，我们可以创建一个可以轻松处理被删除和重新创建的应用程序。</p>
<p>怎么样？简单，减速器组件！ ：P</p>
<p>上面的体系结构可以通过创建处理状态的父组件向上移动到组件树中，并且仅向下传递我们获得两全其美所需的内容。减速器组件模型和状态与短暂组件分离。</p>
<pre><code class="language-ocaml">type element =
  | Todo
  | Counter;

/* 将 state 合并为一个全球 state */
type state = {
  todo: Todo.state,
  counter: Counter.state,
  activeElement: element
};

/* 将来自 todo 和 counter 的动作组合到全局动作包装器中 */
type action =
  | Todo(Todo.action)
  | Counter(Counter.action)
  | ChangeElement(element);

let component = ReasonReact.reducerComponent(&quot;App&quot;);

let make = (_children) =&gt; {
  ...component,
  /* 结合所有初始状态 */
  initialState: () =&gt; {todo: Todo.initialState(), counter: Counter.initialState(), activeElement: Todo},
  /* 让组件减速器处理状态部分 */
  reducer: (action, state) =&gt;
    switch action {
    | Todo(todoAction) =&gt; ReasonReact.Update({...state, todo: Todo.reducer(todoAction, state.todo)})
    | Counter(counterAction) =&gt;
      ReasonReact.Update({...state, counter: Counter.reducer_2(counterAction, state.counter)})
    | ChangeElement(element) =&gt; ReasonReact.Update({...state, activeElement: element})
    },
  render: ({state, send}) =&gt;
    &lt;div&gt;
      &lt;button onClick=((_e) =&gt; send(ChangeElement(Todo)))&gt; (ReasonReact.stringToElement(&quot;todo&quot;)) &lt;/button&gt;
      &lt;button onClick=((_e) =&gt; send(ChangeElement(Counter)))&gt; (ReasonReact.stringToElement(&quot;counter&quot;)) &lt;/button&gt;
      &lt;h1&gt;(ReasonReact.stringToElement(&quot;Component&quot;))&lt;/h1&gt;
      (
        /* 将一段状态传递给组件 */
        switch state.activeElement {
        | Todo =&gt; &lt;Todo todoState=state.todo dispatch=((action) =&gt; send(Todo(action))) /&gt;
        | Counter =&gt; &lt;Counter counterState=state.counter dispatch=((action) =&gt; send(Counter(action))) /&gt;
        }
      )
    &lt;/div&gt;
};
</code></pre>
<p>这确实需要对原始组件进行微小修改。</p>
<pre><code class="language-ocaml">type state = {count: int};

/* 将初始状态移出组件 */
let initialState = () =&gt; {count: 0};

type action =
  | Increment
  | Decrement;

/* 将 reducer 移出组件 */
let reducer = (action, state) =&gt;
  switch action {
  | Increment =&gt; {count: state.count + 1}
  | Decrement =&gt; {count: state.count - 1}
  };

let component = ReasonReact.statelessComponent(&quot;Counter&quot;);

let make = (~dispatch, ~counterState, _children) =&gt; {
  ...component,
  render: (_self) =&gt;
    &lt;div&gt;
      &lt;h1&gt; (ReasonReact.stringToElement(string_of_int(counterState.count))) &lt;/h1&gt;
      /* 使用传入的调度函数而不是self.send */
      &lt;button onClick=((_e) =&gt; dispatch(Increment))&gt; (ReasonReact.stringToElement(&quot;+&quot;)) &lt;/button&gt;
      &lt;button onClick=((_e) =&gt; dispatch(Decrement))&gt; (ReasonReact.stringToElement(&quot;-&quot;)) &lt;/button&gt;
    &lt;/div&gt;
};
</code></pre>
<p>如果你想看到 todo 组件，它在最后链接的源代码中，应用程序托管在http://hehk.github.io/example-reason-react-global-state</p>
<p>正如您所看到的，这些更改非常小，我所做的只是创建一个具有子状态并集的父组件，并让它负责更新该新状态。我们也只是改变原始组件中的一些函数调用来使用新的调度函数，我们是金色的。</p>
<p><img src="/images/1__kAXzPNzq0y1fSyyOjOzOA.gif" alt="示例演示截图" /></p>
<p>管用!</p>
<h2>优点</h2>
<ul>
<li>这将状态与组件分离，您实际上并不需要将 reducer 和初始状态放在同一模块中。它们可能完全不同，处理方式不同。例如，您可以创建一个包含状态，操作和缩减器的语言模块，但没有特定的语言组件，其状态只会传递给组件</li>
<li>您现在可以通过删除和重新创建元素来持续存在</li>
</ul>
<h2>这个方法有问题</h2>
<ul>
<li>这个解决方案相当简单，可能会很快变得难看。</li>
<li>您必须通过 props 将状态显式传递给组件。 **您可以在州周围创建一个 observable，并将所有子组件订阅为一种可能的解决方法。 **</li>
<li>除了通用更新之外的任何更改都需要重写，目前只有子减速器返回状态。你可以让他们返回一个状态和更新类型的元组，但这也只是一个更多的样板。</li>
</ul>
<p>我希望在 Reason / OCaml 上有一个更好的人最终会推出一个优雅的解决方案来打破这个代码，但是，就目前而言，我认为这是一种创建全局状态的简单方法。</p>
<h2>关闭笔记</h2>
<p>感谢阅读，我是新来写博客文章，所以希望它并不可怕。我之所以写这篇文章，是因为我是工作范例的忠实粉丝，我找不到更有趣的状态管理。如果您认为有什么不对或可以更好地解释，请告诉我。</p>
<p>如果您想了解有关使用 reducer 组件的更多信息，请访问https://reasonml.github.io/reason-react/docs/en/state-actions-reducer.html 查看文档。</p>
<p>此帖子的所有代码均来自以下示例应用：https://github.com/Hehk/example-reason-react-global-state</p>
