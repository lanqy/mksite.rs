<h1 id='傻瓜式类型安全绑定从_js_到_reason。'>傻瓜式类型安全绑定从 JS 到 Reason。</h1>

<p>译自： http://blog.klipse.tech/reason/2017/10/17/externals-js-ffi-reason.html</p>

<p>有时，我们需要能够从我们的 Reason 代码中访问 JS 代码。这是所谓的 Javascript 互操作性的一部分。</p>

<p>更具体地说，这叫做 FFI (外部函数接口)。FFI 是一种机制，用一种编程语言编写的程序可以调用例程或使用另一种编程语言编写的服务。</p>

<p>在 Reason 的背景下，为了访问 JS 代码，我们必须从 JS 到 Reason 构建类型安全的绑定。为此，我们必须编写类型声明。</p>

<p>Reason 的 FFI 非常强大，但这种能力是有代价的。了解它的工作原理有点复杂。</p>

<p>本文的目的是以简单的方式公开 Reason 的 FFI 的主要功能，以帮助您克服语法的困难。</p>

<p><img src='/images/burn-out.jpg' alt='烧脑' /></p>

<h2 id='绑定到简单的_js_函数值'>绑定到简单的 JS 函数值</h2>

<p>我们来看看一些例子：</p>

<p>以下是我们如何使 <code>Math.sqrt</code> 函数可以访问我们的 Reason 代码：</p>

<pre><code class="language-ocaml">[@bs.val] external sqrt : float =&gt; float = &quot;Math.sqrt&quot;;
let a = sqrt (2.0);

/* 1.4142135623730951 */</code></pre>

<p>当指定的名称与原始名称完全相同时，我们可以将名称留空：</p>

<pre><code class="language-ocaml">[@bs.val] external encodeURIComponent : string =&gt; string = &quot;&quot;;
let a = encodeURIComponent(&quot;Hello World\n&quot;);

/* Hello%20World%0A */</code></pre>

<h2 id='绑定到_javascript_构造函数：bs.new'>绑定到 JavaScript 构造函数：bs.new</h2>

<p><code>bs.new</code> 用于创建 JavaScript 对象。</p>

<pre><code class="language-ocaml">type date;
[@bs.new] external create_date : unit =&gt; date = &quot;Date&quot;;
let date = create_date ();
/* Fri May 25 2018 14:32:19 GMT+0800 (中国标准时间) */</code></pre>

<h2 id='绑定到方法：bs.send_和_bs.send.pipe'>绑定到方法：bs.send 和 bs.send.pipe</h2>

<p><code>bs.send</code> 允许我们调用一个 JS 对象的方法。例如，这是我们如何绑定 <code>dom.getElementById</code></p>

<p><code>dom</code> 是 <code>DOM</code> 的抽象类型，<code>element</code> 是元素的抽象类型</p>

<pre><code class="language-ocaml">type dom;
[@bs.val] external dom : dom = &quot;document&quot;;
type element;
[@bs.send] external get_by_id : dom =&gt; string =&gt; element = &quot;getElementById&quot;;

let a = get_by_id(dom, &quot;klipse&quot;);</code></pre>

<p>输出</p>

<pre><code class="language-javascript">// Generated by BUCKLESCRIPT VERSION 1.9.2, PLEASE EDIT WITH CARE
&#8217;use strict&#8217;;

var a = document.getElementById(&quot;klipse&quot;);

exports.a = a;
/* a Not a pure module */</code></pre>

<p><code>bs.send.pipe</code> 与 <code>bs.send</code> 相似，除了第一个参数，即对象，放在最后一个参数的位置，以帮助用户以链式编写：</p>

<pre><code class="language-ocaml">[@bs.send.pipe : array(&#8217;a)] external map : ([@bs] (&#8217;a =&gt; &#8217;b)) =&gt; array(&#8217;b) = &quot;&quot;;

let test (arr) =
  arr
  |&gt; map ([@bs] (fun (x) =&gt; x + 1))
  |&gt; map ([@bs] (fun (x) =&gt; x * 4));

let a = test([|1,2,3|]);

/* 8,12,16 */</code></pre>

<p>如果您对 Ocaml / Reason 管道运算符还不熟悉，则这里是经过转换的 js 代码：</p>

<pre><code class="language-ocaml">[@bs.send.pipe : array(&#8217;a)] external map : ([@bs] (&#8217;a =&gt; &#8217;b)) =&gt; array(&#8217;b) = &quot;&quot;;

let test (arr) =
  arr
  |&gt; map ([@bs] (fun (x) =&gt; x + 1))
  |&gt; map ([@bs] (fun (x) =&gt; x * 4));</code></pre>

<p>转换成：</p>

<pre><code class="language-javascript">// Generated by BUCKLESCRIPT VERSION 1.9.2, PLEASE EDIT WITH CARE
&#8217;use strict&#8217;;


function test(arr) {
return arr.map((function (x) {
return x + 1 | 0;
})).map((function (x) {
return (x &lt;&lt; 2);
}));
}

exports.test = test;
/* No side effect */</code></pre>

<blockquote>
<p>如果您对回调中的<a href='https://bucklescript.github.io/bucklescript/Manual.html#_binding_to_callbacks_high_order_function'>@bs]属性感兴趣，请参阅[绑定到回调函数（高阶函数）</a>。</p>
</blockquote>

<p>绑定到动态密钥访问/设置：<code>bs.set_index</code> 和 <code>bs.get_index</code></p>

<p>以下是我们如何对 JavaScript 属性进行动态访问：</p>

<pre><code class="language-ocaml">type js_array;
[@bs.new] external create : int =&gt; js_array = &quot;Int32Array&quot;;
[@bs.get_index] external get : js_array =&gt; int =&gt; int = &quot;&quot;;
[@bs.set_index] external set : js_array =&gt; int =&gt; int =&gt; unit = &quot;&quot;;

let i32arr = create(3);
set(i32arr, 0, 42);
let a = get(i32arr, 0);

/* 42 */</code></pre>

<h2 id='绑定到_getter_/_setter：bs.get，bs.set。'>绑定到 Getter / Setter：bs.get，bs.set。</h2>

<p>该属性有助于获取和设置 JavaScript 对象的属性。</p>

<p>让我们在 javascript klipse 片段中定义一个 javascript 对象：</p>

<pre><code class="language-javascript">var bob = {&quot;name&quot;: &quot;Bob&quot;, &quot;age&quot;: 32};</code></pre>

<p>现在，下面是我们如何创建 setter 和 getter 到这个 javascript 对象（谢谢 @yawaramin，来自 Reason Discord！）：</p>

<pre><code class="language-ocaml">type person;
[@bs.val] external bob : person = &quot;&quot;;
[@bs.get] external get_age : person =&gt; int = &quot;age&quot;;
[@bs.set] external set_age : (person, int) =&gt; unit = &quot;age&quot;;

let () = {
  let bobAge = get_age(bob);
  set_age(bob, bobAge + 1)
}

/* 33 */</code></pre>

<p>只是为了好玩，看一下如何简单和干净的转换的js代码:</p>

<pre><code class="language-ocaml">type person;
[@bs.val] external bob : person = &quot;&quot;;
[@bs.get] external get_age : person =&gt; int = &quot;age&quot;;
[@bs.set] external set_age : (person, int) =&gt; unit = &quot;age&quot;;

let () = {
  let bobAge = get_age(bob);
  set_age(bob, bobAge + 1)
};</code></pre>

<p>转成：</p>

<pre><code class="language-javascript">// Generated by BUCKLESCRIPT VERSION 1.9.2, PLEASE EDIT WITH CARE
&#8217;use strict&#8217;;


var bobAge = bob.age;

bob.age = bobAge + 1 | 0;

/* bobAge Not a pure module */</code></pre>

<h2 id='拼接调用约定：bs.splice'>拼接调用约定：bs.splice</h2>

<p>在 JS 中，有一个函数采用可变参数是很常见的。 BuckleScript 支持类型同质可变参数。我们传递一个数组，而不是传递可变数量的参数：</p>

<pre><code class="language-ocaml">[@bs.val] [@bs.splice] external max : array(int) =&gt; int = &quot;Math.max&quot;;

max([|10, 12, 99|]);

/* 99 */</code></pre>

<h2 id='绑定到来自模块的值：bs.module'>绑定到来自模块的值：bs.module</h2>

<p>我们可以绑定到 js 模块的值：</p>

<pre><code class="language-ocaml">[@bs.module &quot;x&quot;] external add : (int, int) =&gt; int = &quot;add&quot;;

let f = add(3, 4);</code></pre>

<p>转成：</p>

<pre><code class="language-javascript">// Generated by BUCKLESCRIPT VERSION 1.9.2, PLEASE EDIT WITH CARE
&#8217;use strict&#8217;;

var X = require(&quot;x&quot;);

var f = X.add(3, 4);

exports.f = f;
/* f Not a pure module */</code></pre>

<p>我们甚至可以提示编译器为模块生成一个更好的名称：</p>

<pre><code class="language-ocaml">[@bs.module (&quot;x&quot;, &quot;coolx&quot;)] external add : (int, int) =&gt; int = &quot;add&quot;;

let f = add(3, 4);</code></pre>

<p>转成：</p>

<pre><code class="language-javascript">// Generated by BUCKLESCRIPT VERSION 1.9.2, PLEASE EDIT WITH CARE
&#8217;use strict&#8217;;

var CoolX = require(&quot;x&quot;);

var f = CoolX.add(3, 4);

exports.f = f;
/* f Not a pure module */</code></pre>

<p>Bucklescript FFI 还有许多其他高级功能。您可以阅读有关优秀的官方 <a href='https://bucklescript.github.io/bucklescript/Manual.html#_ffi'>BuckleScript手册</a>。</p>

<p>注意到使用 FFI，在 <code>ReasonReact</code> 项目中访问 React.js 组件非常简单，因为它在<a href='https://reasonml.github.io/reason-react/docs/en/interop.html'>这里</a>已经解释了。</p>
