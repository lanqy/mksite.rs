<h1 id='构建一个基于_redux_的_react_应用'>构建一个基于 Redux 的 react 应用</h1>

<p>在这篇文章里，我们将深入理解以及学习为什么开发React应用的时候，使用Redux这么重要。我也将一步一步教你如何创建你的第一个Redux应用，包括怎样使用&lt;a href=&quot;https://github.com/stormpath/stormpath-sdk-react&quot;&gt;Stormpath React SDK &lt;/a&gt;于&lt;a href=&quot;https://stormpath.com/product/authentication/&quot;&gt; user authentication（用户认证）&lt;/a&gt;。当你完成的时候，你将掌握这个知识并运用到你已有到React应用中。</p>

<p>###Redux是什么？</p>

<p>&lt;a href=&quot;https://github.com/reactjs/redux&quot;&gt;Redux&lt;/a&gt;是一个用于帮助我们管理应用状态到的框架(library)。它的设计源于&lt;a href=&quot;https://facebook.github.io/react/docs/flux-overview.html&quot;&gt;Flux&lt;/a&gt;,但是从编写Flux应用的痛苦中进化而来。如果你写过Flux应用，你将很快注意到Redux可以帮你自动做很多以前你需要手动做的事情，还有，你只有一个单一的状态容器，这是一个很大的优势，这样在你的应用中共享状态和重用代码会变得更加简单。</p>

<h3 id='stores'>Stores</h3>

<p>store是一个简单的状态容器，这是存储你应用状态和actions调度和处理的地方。当你开始创建一个Redux应用时，你要想想你的应用程序的数据和状态应该如何存储。这是很重要的，因为Redux推荐一个应用只有一个store，而且由于状态是共享的，因此在开始创建应用的时候，想好这些尤为重要。</p>

<h3 id='actions'>Actions</h3>

<p>Actions 是一些用于描述我们怎样改变我们应用状态的对象，你可以这么认为actions就是我们状态树的API。例如，一个添加用户的action可以像这样：</p>

<pre><code class="language-javascript">{
  type: &#8217;ADD_USER&#8217;,
  data: {
    name: &#8217;Foo&#8217;,
    email: &#8217;foo@bar.com&#8217;,
    password: &#8217;Foobar123_&#8217;
  }
}</code></pre>

<pre><code class="language-了让代码更清晰，更易于重用,通常是使用一个生成器(方法)生成操作对象，即，上面的例子，我们可以创建一个类似于```addUser(name, email, password) ```的函数来生成对象。如你所见，actions本身什么都不做，一个action仅仅是一个用于描述我们怎样改变我们应用状态的对象。">### Reducers

Actions很酷，但是它们并没有太大的意义。这就是reducers存在的意义。
Reducers是action处理器，用于在store中调度actions以及在状态变化中简化actions操作。如果我们要在store中调度action（ADD_USER）,我们将拥有一个reducer调用action(ADD_USER)并添加一个新的用户到我们到应用状态中。
### 创建Redux应用
现在，当你了解的基础知识以后，让我们继续创建我们第一个基于Redux的应用程序。&lt;br/&gt;
为了让事情变得简单，我们将要创建一个todo应用程序，这样我们可以玩转很多Redux的重要概念，而不用过多的关注应用本身。&lt;br/&gt;
我们考虑一下一个todo应用程序，需要些什么基本的东西。首先一个todo程序，由一个列表组成。其实这个列表包含一些我们可以改变的项目。&lt;br/&gt;
从应用的状态来看，我们可以这样定义我们的模型（model）：</code></pre>

<p>{ todo: {</p>

<pre><code>items: [
  {
    message: &quot;Finish Redux blog post...&quot;,
    completed: false
  }
]</code></pre>

<p>} }</p>

<pre><code>### 添加 Actions

我们要怎样处理我们应用的状态呢？首先，我们添加一个新待办项目到我们状态中去，让我们创建一个action来做这件事：</code></pre>

<p>function addTodo(message) { return {</p>

<pre><code>type: &#8217;ADD_TODO&#8217;,
message: message,
completed: false</code></pre>

<p>}; }</p>

<pre><code></code></pre>

<p>type字段的约定格式为大写字母，并且每个单词以下划线作为分隔，接下来你将使用这个名字／标示符在你的reducers中来处理具体的actions，并把它们变成可变的状态。&lt;br/&gt; 一旦我们增加了我们的待办事项，我们肯定希望能够将其标记为已完成状态，我们也可以删除它，可以清空所有的待办项目。&lt;br/&gt; 因此让我们创建actions来做这些事情：</p>

<pre><code class="language-javascript">function completeTodo(index) {
  return {
    type: &#8217;COMPLETE_TODO&#8217;,
    index: index
  };
}

function deleteTodo(index) {
  return {
    type: &#8217;DELETE_TODO&#8217;,
    index: index
  };
}

function clearTodo() {
  return {
    type: &#8217;CLEAR_TODO&#8217;
  };
}</code></pre>

<p>到目前为止，我们已经定义好我们的actions，让我们继续定义我们的store，如前所述，store是Redux应用的核心，所有的状态(state)、调度器(dispatched actions)、reducers都依赖于它。</p>

<pre><code class="language-javascript">import { createStore } from &#8217;redux&#8217;;

var defaultState = {
  todo: {
    items: []
  }
};

function todoApp(state, action) {
}

var store = redux.createStore(todoApp, defaultState);</code></pre>

<h3 id='添加reducers'>添加Reducers</h3>

<p>现在，我们已经拥有一些actions和一个store。让我们创建我们的第一个reducer，如前所述，reducer仅仅是一个action处理器，拥有处理actions和改变应用的状态（state）。</p>

<pre><code class="language-我们先处理我们的```ADD_TODO``` action，如下所示："></code></pre>

<p>function todoApp(state, action) { switch (action.type) {</p>

<pre><code>case &#8217;ADD_TODO&#8217;:
  var newState = Object.assign({}, state);</code></pre>

<pre><code>  newState.todo.items.push({
    message: action.message,
    completed: false
  });</code></pre>

<pre><code>  return newState;</code></pre>

<pre><code>default:
  return state;</code></pre>

<p>} }</p>

<pre><code>注意，当我们说一个reducer“改变”了应用的状态，如果一个状态需要改变，我们真正要做的是创建一个状态（state）的副本，并修改这个状态的副本。如果状态没有改变,那我们就返回相同的状态。任何情况下，如果你直接修改原始的状态（state），这意味着你将改变状态的历史。&lt;br/&gt;
现在我们有了第一个我们的action处理器，让我们添加其它的：&lt;br/&gt;</code></pre>

<p>function todoApp(state, action) { switch (action.type) {</p>

<pre><code>case &#8217;ADD_TODO&#8217;:
  var newState = Object.assign({}, state);</code></pre>

<pre><code>  newState.todo.items.push({
    message: action.message,
    completed: false
  });</code></pre>

<pre><code>  return newState;</code></pre>

<pre><code>case &#8217;COMPLETE_TODO&#8217;:
  var newState = Object.assign({}, state);</code></pre>

<pre><code>  newState.todo.items[action.index].completed = true;</code></pre>

<pre><code>  return newState;</code></pre>

<pre><code>case &#8217;DELETE_TODO&#8217;:
  var items = [].concat(state.todo.items);</code></pre>

<pre><code>  items.splice(action.index, 1);</code></pre>

<pre><code>  return Object.assign({}, state, {
    todo: {
      items: items
    }
  });</code></pre>

<pre><code>case &#8217;CLEAR_TODO&#8217;:
  return Object.assign({}, state, {
    todo: {
      items: []
    }
  });</code></pre>

<pre><code>default:
  return state;</code></pre>

<p>} }</p>

<pre><code>###结合React UI
现在，我们已经制定了业务逻辑，让我们写一些UI代码，由于大部分React的知识都跟构建Flux应用类似，我们就不再深入讲解。一下是我们的代码：</code></pre>

<p>import React from &#8217;react&#8217;; import ReactDOM from &#8217;react-dom&#8217;; import { createStore } from &#8217;redux&#8217;;</p>

<p>var defaultState = { todo: {</p>

<pre><code>items: []</code></pre>

<p>} };</p>

<p>// Add the actions here that we created in the previous steps...</p>

<p>function todoApp(state, action) { // Add the reducer logic that we added in the previous steps... }</p>

<p>var store = createStore(todoApp, defaultState);</p>

<p>class AddTodoForm extends React.Component { state = {</p>

<pre><code>message: &#8217;&#8217;</code></pre>

<p>};</p>

<p>onFormSubmit(e) {</p>

<pre><code>e.preventDefault();
store.dispatch(addTodo(this.state.message));
this.setState({ message: &#8217;&#8217; });</code></pre>

<p>}</p>

<p>onMessageChanged(e) {</p>

<pre><code>var message = e.target.value;
this.setState({ message: message });</code></pre>

<p>}</p>

<p>render() {</p>

<pre><code>return (
  &lt;form onSubmit={this.onFormSubmit.bind(this)}&gt;
    &lt;input type=&quot;text&quot; placeholder=&quot;Todo...&quot; onChange={this.onMessageChanged.bind(this)} value={this.state.message} /&gt;
    &lt;input type=&quot;submit&quot; value=&quot;Add&quot; /&gt;
  &lt;/form&gt;
);</code></pre>

<p>} }</p>

<p>class TodoItem extends React.Component { onDeleteClick() {</p>

<pre><code>store.dispatch(deleteTodo(this.props.index));</code></pre>

<p>}</p>

<p>onCompletedClick() {</p>

<pre><code>store.dispatch(completeTodo(this.props.index));</code></pre>

<p>}</p>

<p>render() {</p>

<pre><code>return (
  &lt;li&gt;
    &lt;a href=&quot;#&quot; onClick={this.onCompletedClick.bind(this)} style=&gt;{this.props.message.trim()}&lt;/a&gt;&amp;nbsp;
    &lt;a href=&quot;#&quot; onClick={this.onDeleteClick.bind(this)} style=&gt;[x]&lt;/a&gt;
  &lt;/li&gt;
);</code></pre>

<p>} }</p>

<p>class TodoList extends React.Component { state = {</p>

<pre><code>items: []</code></pre>

<p>};</p>

<p>componentWillMount() {</p>

<pre><code>store.subscribe(() =&gt; {
  var state = store.getState();
  this.setState({
    items: state.todo.items
  });
});</code></pre>

<p>}</p>

<p>render() {</p>

<pre><code>var items = [];</code></pre>

<pre><code>this.state.items.forEach((item, index) =&gt; {
  items.push(&lt;TodoItem
    key={index}
    index={index}
    message={item.message}
    completed={item.completed}
  /&gt;);
});</code></pre>

<pre><code>if (!items.length) {
  return (
    &lt;p&gt;
      &lt;i&gt;Please add something to do.&lt;/i&gt;
    &lt;/p&gt;
  );
}</code></pre>

<pre><code>return (
  &lt;ol&gt;{ items }&lt;/ol&gt;
);</code></pre>

<p>} }</p>

<p>ReactDOM.render( &lt;div&gt;</p>

<pre><code>&lt;h1&gt;Todo&lt;/h1&gt;
&lt;AddTodoForm /&gt;
&lt;TodoList /&gt;</code></pre>

<p>&lt;/div&gt;, document.getElementById(&#8217;container&#8217;) );</p>

<pre><code></code></pre>

<h3 id='在stormpath_react_sdk中支持redux'>在Stormpath React SDK中支持Redux</h3>

<p>因为有不少请求为Stormpath React SDK添加Redux支持，因此我们实现了这个功能，如果你想配置SDK来使用Redux，简单配置dispatcher选项并设置几个type和redux指向store，具体如下:</p>

<pre><code class="language-javascript">function myApp(state, action) {
  return state;
}

ReactStormpath.init({
  dispatcher: {
    type: &#8217;redux&#8217;,
    store: createStore(myApp)
  }
});</code></pre>

<pre><code class="language-旦做到这一点，我们就可以通过Stormpath React SDK拦截和处理我们的actions调度，例如，如果你希望通过用户数据来丰富你的状态，那么简单地处理```USER_SET```action来添加用户数据到你的状态中。"></code></pre>

<p>function myApp(state, action) { switch (action.type) {</p>

<pre><code>case &#8217;USER_SET&#8217;:
  return Object.assign({}, state, {
    user: action.data
  });</code></pre>

<pre><code>default:
  return state;</code></pre>

<p>} } <code>`</code> ###总结 正如你在文章中所看到的一样，构建一个Redux应用是非常简单和直接的。这就像是构建Flux应用一样，仅仅是概念上的差异，并且手动写的代码变得更少。希望你们喜欢这个教程，并且发现未来你可以使用它。如果有任何问题，请参考github上的&lt;a href=&quot;https://github.com/typerandom/stormpath-react-redux-todo-example-application&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;。&lt;br/&gt; ###扩展阅读 想要学习更多关于给React应用添加用户认证，请看以下教程：</p>

<ul>
<li>&lt;a href=&quot;https://stormpath.com/blog/build-a-react-app-with-user-authentication/&quot;&gt;Tutorial: Build a React.js Application With User Authentication&lt;/a&gt;</li>

<li>&lt;a href=&quot;https://stormpath.com/blog/react-sdk-custom-forms/&quot;&gt;Custom Login and Registration Forms&lt;/a&gt;</li>
</ul>

<p>注：本文翻译自&lt;a href=&quot;https://stormpath.com/blog/build-a-redux-powered-react-application/&quot; target=&quot;_blank&quot;&gt;Let&#8217;s Build a Redux Powered React Application&lt;/a&gt;,如有翻译不对的地方请指正。谢谢！</p>
