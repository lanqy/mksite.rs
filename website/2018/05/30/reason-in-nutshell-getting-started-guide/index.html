<h1>Reason 入门手册</h1>
<p>译自：https://zaiste.net/reason_in_nutshell_getting_started_guide/</p>
<p><img src="/images/zaiste-reason.png" alt="Reason" /></p>
<blockquote>
<p>本教程旨在提供对 Reason 的全面但相对较短的介绍。</p>
</blockquote>
<p><a href="https://reasonml.github.io/">Reason</a> 是一种构建在 <a href="https://ocaml.org/">OCaml</a> 之上的编程语言。它提供了函数式和面向对象的功能，并且具有类型安全性并关注性能。它是在 Facebook 创建的。它的语法与 JavaScript 类似。目的是使 JavaScript 与 JavaScript 程序员的互操作更容易。Reason 可以访问 JavaScript 和 OCaml 生态系统。OCaml 创建于 1996 年，它是一种具有类型推导的函数式编程语言。</p>
<p>Reason 网站包含一个<a href="https://reasonml.github.io/en/try.html">在线游乐场</a>。它允许使用该语言并直观的查看生成的 JavaScript。它也可以从 OCaml 转换为 Reason。</p>
<h2>为什么</h2>
<ul>
<li>在 JavaScript 类型注释中，linting 或统一格式是作为外部依赖项提供的，例如 Flow，TypeScript，ESLint 或 Prettier。Reason 提供了这些功能的开箱即用。这使得开发过程更加简化和方便。</li>
<li>Reason 提供对 <a href="https://reasonml.github.io/reason-react/">ReasonReact</a> 的 React 支持。它还支持 JSX 语法（ React 中使用的类似 HTML 的语法）。开箱即用</li>
<li>Reason 还有生成本机二进制文件的能力。生成的代码是高性能的。没有虚拟机开销。它提供了一个便于部署过程的二进制文件。</li>
</ul>
<h2>它是如何工作的</h2>
<p>Reason 被编译为 OCaml 的抽象语法树。这使 Reason 成为一个转译器。 OCaml 不能直接在浏览器中运行。AST 可以转换为各种目标。可以使用 BuckleScript 将 AST 编译为 JavaScript。它还提供了 OCaml 和 JavaScript 生态系统之间的互操作。</p>
<p>BuckleScript 速度极快，可生成可读的 JavaScript。它还提供了外部函数接口（FFI）以允许与 JavaScript 现有库的互操作性。检查<a href="https://github.com/neonsquare/bucklescript-benchmark">BuckleScript 基准</a>。 BuckleScript 由 Messanger 团队在 Facebook 上使用，在 WebAssembly spec 解释器上由 Google 使用。在这里检查 Bucklescript 演示。 BuckleScript 由 <a href="https://twitter.com/bobzhang1988/">Hongbo Zhang</a> 创建。</p>
<h2>你好 Reason</h2>
<p>我们将使用 BuckleScript 生成一个 Reason 项目。该工具提供即时可用的项目模板，称为 <code>themes</code>。</p>
<p>我们先从全局安装 <code>bs-platform</code> 开始：</p>
<pre><code class="language-ocaml">npm install -g bs-platform
</code></pre>
<p>我们现在可以使用 <code>bs-platform</code> 提供的 <code>bsb</code> 二进制文件生成项目脚手架。我们将使用 <code>basic-reason</code> 模板从最基本的 Reason 项目结构开始。</p>
<pre><code class="language-ocaml">bsb -init reason-1 -theme basic-reason
</code></pre>
<pre><code class="language-ocaml">Making directory reason-1
Symlink bs-platform in /Users/zaiste/code/reason-1
</code></pre>
<p>以下是通过 BuckleScript 从 <code>basic-reason</code> 模板生成的 Reason 目录结构：</p>
<pre><code class="language-ocaml">.
├── README.md
├── bsconfig.json
├── lib
├── node_modules
├── package.json
└── src
    └── Demo.re
</code></pre>
<p><code>bsconfig.json</code> 包含 Reason 项目的 BuckleScript 配置。它允许指定要通过源编译的文件，通过 <code>bs-dependencies</code> 的 BuckleScript 依赖关系，编译器的附加标志等等。</p>
<p>下一步是构建项目。这将采取 Reason 代码并通过 BuckleScript 传递它以生成 JavaScript。默认情况下，编译器将以 Node.js 为目标。</p>
<pre><code class="language-ocaml">npm run build
</code></pre>
<pre><code class="language-ocaml">(* 输出 *)
&gt; reason-1@0.1.0 build /Users/zaiste/code/reason-1
&gt; bsb -make-world

ninja: Entering directory `lib/bs'
[3/3] Building src/Demo.mlast.d
[1/1] Building src/Demo-MyFirstReasonml.cmj
</code></pre>
<p>最后，我们可以使用 <code>node</code> 来运行 由 BuckleScript 生成的文件。</p>
<pre><code class="language-ocaml">node src/Demo.bs.js

(* 将输出 Hello, BuckleScript and Reason! *)
</code></pre>
<h2>语法 101</h2>
<p>在本节中，我将详细介绍我发现的特殊的，新的或不同的语法元素。</p>
<h3>模块</h3>
<p>Reason 文件是模块。在 JavaScript 或类似的编程语言中没有 <code>require</code> 或 <code>import</code> 语句。模块定义必须以模块名称作为前缀以在外部工作。该功能来自 OCaml 。因此，您可以自由移动文件系统中的模块文件，而无需修改代码。</p>
<h3>函数</h3>
<p>函数使用 <code>let</code> 和 <code>=&gt;</code> 来定义。</p>
<pre><code class="language-ocaml">let greet = name =&gt;
    Js.log(&quot;Hello, &quot; ++ name ++ &quot;!&quot;);

greet(&quot;Zaiste&quot;);
</code></pre>
<p><code>++</code> 运算符用于连接字符串。</p>
<p>函数的输入参数可以被标记。这使得函数调用更加明确：传入的值不再需要遵循函数定义中的参数顺序。用 <code>~</code> 作为参数名称的前缀使其标记。</p>
<pre><code class="language-ocaml">let greet = (~name, ~location) =&gt;
    Js.log(&quot;Hello, &quot; ++ name ++ &quot;! You're in &quot; ++ location);

greet(~location=&quot;Vienna&quot;, ~name=&quot;Zaiste&quot;);
</code></pre>
<h3>数据结构</h3>
<h4>变体</h4>
<p>变体是一个数据结构，它保存来自一组固定值的值。这也被称为标记或不相交联合或代数数据类型。变体中的每个案例都必须大写。可选，它可以接收参数。</p>
<pre><code class="language-ocaml">type animal = 
    | Dog
    | Cat
    | Bird;
</code></pre>
<h4>记录</h4>
<p>这是一个记录</p>
<pre><code class="language-ocaml">let p = {
    name: &quot;Zaiste&quot;,
    age: 13
}
</code></pre>
<p>记录需要明确的类型定义。</p>
<pre><code class="language-ocaml">type person = {
    name: string,
    age: int
}
</code></pre>
<p>在模块的作用域中，类型将被继承：p 绑定将被识别为 <code>person</code> 类型。在模块之外，您可以通过在文件名前添加前缀来引用该类型。</p>
<pre><code class="language-ocaml">let p: Person.person = {
    name: &quot;Sean&quot;,
    age: 12
}
</code></pre>
<p>有一个约定为每个类型创建一个模块并将类型命名为 <code>t</code> 以避免重复，即用 <code>Person.t</code> 代替 <code>Person.person</code>。</p>
<h3>异步编程和 Promise</h3>
<p>通过 BuckleScript 提供的内置 Promise 支持，作为 JS.Promise 模块提供。以下是使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a> 进行 API 调用的示例：</p>
<pre><code class="language-ocaml">Js.Promise.(
    Fetch.fetch(endpoint)
    |&gt; then_(Fetch.Response.json)
    |&gt; then_(json =&gt; doSomethingOnReponse(json) |&gt; resolve)
)
</code></pre>
<p>您需要使用 <code>then_</code> ，因为 <code>then</code> 是 OCaml 中的保留字。</p>
<h3>模式匹配</h3>
<p>模式匹配是基于提供值的形状的调度机制。在 Reason 中，模式匹配是通过 <code>switch</code> 语句实现的。它可以与变体类型或解构机制一起使用。</p>
<pre><code class="language-ocaml">switch pet {
    | Dog =&gt; &quot;woof&quot;
    | Cat =&gt; &quot;meow&quot;
    | Bird =&gt; &quot;chirp&quot;
};
</code></pre>
<p>我们可以使用模式匹配进行列表解构：</p>
<pre><code class="language-ocaml">let numbers = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;];
switch numbers {
    | [] =&gt; &quot;Empty&quot;
    | [n1] =&gt; &quot;Only one number: &quot; ++ n1
    | [n1, n2] =&gt; &quot;Only two numbers&quot;
    | [n1, _, n3, ...rest] =&gt; &quot;At least three numbers&quot;
}
</code></pre>
<p>或者，我们可以将其用于记录解构</p>
<pre><code class="language-ocaml">let project = {
    name: &quot;Huncwot&quot;,
    size: 101101,
    forks: 42,
    deps: [{name: &quot;axios&quot;}, {name: &quot;sqlite3&quot;}]
};

switch project {
    | {name: &quot;Huncwot&quot;, deps} =&gt; &quot;Matching by `name`&quot;
    | {location, years: [{name: &quot;axios&quot;}, ...rest]} =&gt; &quot;Matching by one of `deps`&quot;
    | project =&gt; &quot;Any other situation&quot;
}
</code></pre>
<h3>可选值</h3>
<p>option() 是 Reason 中描述 “ <code>nullable</code> (可空)” 值的内置变量：</p>
<pre><code class="language-ocaml">type option('a) = None | Some('a);
</code></pre>
<h3>不同</h3>
<ul>
<li><code>unit</code> 意味着“无”</li>
<li><code>unit =&gt; unit</code> 是一个函数的签名，它不接受任何输入参数并且不返回任何值;主要用于回调函数</li>
</ul>
<h2>Reason 中的 React</h2>
<h3>你好 ReasonReact</h3>
<p><a href="https://reasonml.github.io/reason-react/">ReasonReact</a> 是一个 Reason 中用于创建 React 应用程序的内置功能。</p>
<p>我们使用 BuckleScript 及其 <code>React</code> 模板创建一个 ReasonReact 项目。</p>
<pre><code class="language-ocaml">bsb -init reasonreact-1 -theme react
</code></pre>
<p>Reason 团队推荐 ReasonReact 项目脚手架使用此方法。也可以使用带有 <a href="https://github.com/reasonml-community/reason-scripts">reason-scripts</a> 模板的 yarn 来获得更完整的起点。</p>
<p>ReasonReact 提供了两种类型的组件：<code>statelessComponent</code> 和 <code>reducerComponent</code>。与 <code>stateless</code> (无状态)组件相反，<code>reducer</code> (减速器)组件是有状态的，提供类似 Redux 的 <code>reducer</code>。</p>
<pre><code class="language-ocaml">let s = ReasonReact.string;

let component = ReasonReact.statelessComponent(&quot;App&quot;);

let make = (~message, _children) =&gt; {
    ...component,
    render: _self =&gt; 
        &lt;h1 className=&quot;header&quot;&gt;(s(message))&lt;/h1&gt;
}
</code></pre>
<p>如前所述 <code>~</code> 指定一个带标号的参数来自由排序函数的输入参数。绑定名称中的 <code>_</code> 告诉编译器该函数的主体中未使用该参数。扩展运算符（<code>...</code>）与 <code>component</code> (组件)一起意味着我们扩展了现有的组件。在这个例子中，我们也重写（覆盖）了 <code>render</code> 函数。</p>
<p>Reason 中的 JSX 比 React 更严格：我们需要使用 <code>ReasonReact.string()</code> 显式包装字符串。</p>
<h3>构建非平凡的 ReasonReact 应用程序</h3>
<p>让我们构建一个超越显示预定义数据的 ReasonReact 应用程序。我们将为趋势库创建一个 GitHub 查看器。目的是展示如何与外部 API 集成，如何管理状态以及如何使用 React 的生命周期方法的方法。</p>
<p>为了这个例子的目的，我们将使用 <a href="https://github.com/reasonml-community/reason-scripts">reason-scripts</a> 来引导我们的 Reason 项目。</p>
<pre><code class="language-ocaml">yarn create react-app reasonreact-github --scripts-version reason-scripts
</code></pre>
<p>安装依赖</p>
<pre><code class="language-ocaml">cd reasonreact-github
yarn
</code></pre>
<p>从以下开始：</p>
<pre><code class="language-ocaml">yarn start
</code></pre>
<p><em><strong>存储库</strong></em>是这个应用程序的中心概念。我们首先定义一个描述该实体的类型。我们将把它放在一个名为 Repo 的单独模块中。</p>
<pre><code class="language-ocaml">type t = {
    name: string,
    size: int,
    forks: int
};
</code></pre>
<p>从现在开始，我们可以从应用程序中的任何 Reason 文件引用此类型的 <code>Repo.t</code>，而不需要 requiring（引入）它。</p>
<h3>管理状态</h3>
<p>我们已经看到了一个无状态的组件。现在让我们创建一个具有状态的组件。在我们的上下文中，我们将使用 <code>RepoList</code> 组件管理从 GitHub 的 API 中获取的趋势库列表。</p>
<p>首先定义由 <code>RepoList</code> 组件管理的状态的类型。</p>
<pre><code class="language-ocaml">type state = {
    repos: list(Repo.t)
}
</code></pre>
<p>但是，有一个问题。最初，在从 GitHub API 获取趋势库列表之前，<code>repos</code> 是未定义的。Reason 类型系统不允许我们有 <code>undefined </code> (未定义) 的值。我们可以用一个空列表来模拟初始状态，但这不是最优的。空列表还可能意味着我们对提取趋势库的查询没有返回任何结果。</p>
<p>让我们使用 Reason 的可选值来处理这种情况。</p>
<pre><code class="language-ocaml">type state = {
    repos: option(list(Repo.t))
}
</code></pre>
<p>下一步是定义该组件的可能操作。在ReasonReact中， <code>actions</code> (操作)表示为变体。现在我们只会有一个名为 <code>ReposFetched</code> 的 <code>action</code> (操作)。</p>
<pre><code class="language-ocaml">type action = 
    | ReposFetched(list(Repo.t));
</code></pre>
<p>为了在 ReasonReact 中创建一个有状态的组件，我们需要使用 <code>reducerComponent()</code> 函数。</p>
<pre><code class="language-ocaml">let component = ReasonReact.reducerComponent(&quot;App&quot;);
</code></pre>
<p>这样的组件允许定义描述状态如何响应于 <code>actions</code> (动作)而被转换的 <code>reducer</code> (减速器)。Reducer将当前状态作为输入采取<code>actions</code> (动作)并将新状态作为输出返回。<code>reducer</code> (减速器)必须是纯粹的函数。</p>
<pre><code class="language-ocaml">reducer: (action, _prevState) =&gt; {
    switch action {
        | ReposFetched(repos) =&gt;
            ReasonReact.Update({repos: Some(repos)})
    }
};
</code></pre>
<p>基于我们在 <code>reducer()</code> 方法中收到的参数，我们是模式匹配 <code>action</code> (操作)。模式匹配必须是详尽的。所有变体值必须匹配。<code>reducer</code> 定义放置在组件的 <code>main</code> 函数中。</p>
<p>为了完成组件的定义，我们来定义它的初始状态：</p>
<pre><code class="language-ocaml">initialState: () =&gt; {
    repos: Some([
        {
            name: &quot;Huncwot&quot;,
            size: 101101,
            forks: 42
        }
    ])
};
</code></pre>
<h3>与 API 集成</h3>
<p>我们将使用 <a href="https://github.com/reasonml-community/bs-fetch">bs-fetch</a> 从外部 API 获取数据。它是一个 BuckleScript 库，充当 Fetch API 之上的一个薄层。一旦数据被提取，我们将使用 <code>bs-json</code> 来提取我们感兴趣的字段。</p>
<p>开始安装 <code>bs-fetch</code> 和 <code>bs-json</code>：</p>
<pre><code class="language-ocaml">npm i bs-fetch @glennsl/bs-json
</code></pre>
<p>将它们添加到 <code>bsconfig.json</code> 中的 <code>bs-dependencies</code>：</p>
<pre><code class="language-ocaml">{
    &quot;bs-dependencies&quot;: [
        ...,
        &quot;bs-fetch&quot;,
        &quot;@glennsl/bs-json&quot;
    ]s
}
</code></pre>
<p>我们将 Repo 类型定义为一组三个字段：<code>name</code>，<code>size</code> 和 <code>forks</code>。一旦从 GitHub API 获取有效载荷，我们就解析它以提取这三个字段。</p>
<pre><code class="language-ocaml">let parse = json =&gt;
    Json.Decode.{
        name: json |&gt; field(&quot;name&quot;, string),
        size: json |&gt; field(&quot;size&quot;, int),
        forks: json |&gt; field(&quot;forks&quot;, int)
    }
</code></pre>
<p><code>field</code> 是 <code>Json.Decode</code> 的一个方法。<code>Json.Decode.{...}</code>（注意这个点号）打开 <code>Json.Decode</code> 模块。它的属性现在可以在这些大括号内使用，而不需要使用 <code>Json.Decode</code> 作为前缀。</p>
<p>由于 GitHub 在 <code>items</code> 下返回 <code>repos</code> ，我们定义另一个函数来获取该列表。</p>
<pre><code class="language-ocaml">let extract = (fields, json) =&gt;
    Json.Decode.(
        json |&gt; at(field, list(parse))
    );
</code></pre>
<p>最后，我们可以发出请求并通过解析函数传递返回的数据：</p>
<pre><code class="language-ocaml">let list = () =&gt; 
    Js.Promise.(
        Fetch.fetch(endpoint)
        |&gt; then_(Fetch.Response.json)
        |&gt; then_(text =&gt; extract([&quot;items&quot;], text) |&gt; resolve)
    );
</code></pre>
<h3>React 生命周期方法</h3>
<p>让我们使用 <code>didMount</code> 生命周期方法触发从 GitHub API 获取存储库。</p>
<pre><code class="language-ocaml">didMount: self =&gt; {
    let handle = repos =&gt; self.send(ReposFetched(repos));
    Repo.list()
    |&gt; Js.Promise.then_(repos =&gt; {
        handle(repos);
        Js.Promise.resolve();
    });
    |&gt; ignore;
};
</code></pre>
<p><code>handle</code> 是一个将 <code>ReposFetched</code> 操作分派给 <code>reducer</code> 的方法。一旦承诺解决，操作将把获取的存储库传送到 <code>reducer</code> (减速器)。这将更新我们的状态。</p>
<h3>渲染</h3>
<p>由于我们区分了非初始化状态和存储空列表，因此处理初始<em><strong>加载进度</strong></em>消息很简单。</p>
<pre><code class="language-ocaml">render: self =&gt; {
    &lt;div&gt;
    (
        switch self.state.repos {
            | None =&gt; s(&quot;Loading repositories...&quot;)
            | Some([]) =&gt; s(&quot;Empty list&quot;)
            | Some(repos) =&gt;
            &lt;ul&gt;
            (
                repos
                |&gt; List.map((repo: Repo.t) =&gt; &lt;li&gt; (s(repo.name)) &lt;/li&gt;)
                |&gt; Array.of_list
                |&gt; ReasonReact.array
            )
            &lt;/ul&gt;
        }
    )
    &lt;/div&gt;
};
</code></pre>
<h3>错误处理</h3>
<p>无</p>
<h3>CSS 中的类型</h3>
<p>使用 <a href="https://github.com/SentiaAnalytics/bs-css">bs-css</a> 的 CSS 类型。</p>
<p>通过 <code>yarn</code> 安装</p>
<pre><code class="language-ocaml">yarn add bs-css
</code></pre>
<p>并将它添加到 <code>bsconfig.json</code> 中的 <code>bs-dependencies</code>：</p>
<pre><code class="language-ocaml">&quot;bs-dependencies&quot;: [
  ...,
  &quot;bs-css&quot;
]
</code></pre>
<p>组件：</p>
<pre><code class="language-ocaml">let style = 
    Css.(
        {
            &quot;header&quot;: style([backgroundColor(rgba(111, 37, 35, 1.0)), display(Flex)]),
            &quot;title&quot;: style([color(white), fontSize(px(28)), fontWeight(Bold)]),
        }
    );

let make = _children =&gt; {
    ...component,
    render: _self =&gt;
    &lt;header className=style##header&gt;
        &lt;h1 className=style##title&gt; (s(&quot;This is title&quot;)) &lt;/h1&gt;
    &lt;/header&gt;
};
</code></pre>
<h2>词汇</h2>
<ul>
<li><code>rtop</code> 是 Reason 的交互式命令行。</li>
<li>Merlin 是 OCaml 和 Reason 的自动完成服务文件。</li>
<li>[@bs...] FFI 的 Bucklescript 注释</li>
</ul>
<h2>其他资源</h2>
<ul>
<li><a href="https://github.com/vramana/awesome-reasonml">Awesome ReasonML</a></li>
<li><a href="https://realworldocaml.org/">Real World OCaml</a></li>
<li>http://2ality.com/archive.html?tag=reasonml</li>
<li>https://jamesfriend.com.au/a-first-reason-react-app-for-js-developers</li>
<li>https://github.com/reasonml-community/reason-scripts</li>
<li>https://dev.to/jlewin_/reasonml-getting-started-53gi</li>
<li>https://medium.com/@ryyppy/a-quick-look-on-my-reasonml-workflow-with-vscode-637685f9417a</li>
<li>https://redex.github.io/</li>
<li>https://github.com/arecvlohe/reasonml-cheat-sheet</li>
<li>https://news.ycombinator.com/item?id=16500481</li>
<li><a href="https://github.com/reasonml/reason-tools">ReasonTools browser extension</a></li>
</ul>
<h2>待定</h2>
<pre><code class="language-ocaml">module History = {
    type h;
    [@bs.send] external goBack : h =&gt; unit = &quot;&quot;;
    [@bs.send] external goForward: h =&gt; unit = &quot;&quot;;
    [@bs.send] external go : (h, ~jumps: int) =&gt; unit = &quot;&quot;;
    [@bs.get] external length : h =&gt; int = &quot;&quot;;
};
</code></pre>
<p>BuckleScript 允许我们将原始 JavaScript 与 Reason 代码混合使用。</p>
<pre><code class="language-ocaml">[%bs.raw {|require('./app.css')|}];
</code></pre>
