<h1 id='在_reasonreact中解码_json'>在 ReasonReact中解码 JSON</h1>

<p>译自：https://medium.com/@idkjs/decoding-json-in-reasonreact-cff3a07c1200</p>

<p><img src='/images/1_OizIr4Tc2m6lCGdr9478ew.png' alt='在ReasonReact中解码JSON' /></p>

<p>Reason 是一种新的来自 Facebook 的静态类型函数编程语言，可以编译为 Javascript。ReasonReact 是 React 的一个包装器，可以很容易地在 Reason 中使用。</p>

<p>我们将构建一个小型单页网络应用程序，通过其步伐放置 Reason React。该应用将显示与 Reason 相关的最佳 Github repos 列表。这是一个足够小的任务，我们可以在几个小时内完成它，但是它也有足够的复杂性使我们可以开始厌倦这种新语言。本教程预期不存在 Reason 的现有知识，但对静态类型的基本熟悉会有所帮助。</p>

<h2 id='一个新项目'>一个新项目</h2>

<p>我们将使用使用 <code>create-react-app</code> 的 <code>reason-scripts</code>，这将为我们的应用程序创建一个起点，该应用程序将被称为 <code>decode-json</code>：</p>

<pre><code class="language-ocaml">yarn create react-app decoding-reason --script-version reason-scripts</code></pre>

<p>通过运行 <code>yarn start</code> 来启动项目,在浏览器中打开 <code>https://localhost:3000</code>。</p>

<h2 id='记录类型'>记录类型</h2>

<p>我们将解码来自此Github API请求的公共数据的响应：https://api.github.com/search/repositories?q=topic%3Areasonml&amp;type=Repositories 但首先可以使用假数据进行设置。</p>

<p>创建一个名为 <code>RepoData.re</code> 的新文件并将其添加到其中。</p>

<pre><code class="language-ocaml">type repo = {
    full_name: string,
    stargazers_count: int,
    html_url: string
};</code></pre>

<h2 id='文件既是模块'>文件既是模块</h2>

<p>我们已经在文件的顶层定义了我们的类型。</p>

<blockquote>
<p>顶层基本上意味着视觉上，没有缩进（非常糟糕的解释方式，但你明白了）。<code>let foo = 1</code>不嵌套在其他任何内容中都是顶级的。<code>let foo = 1</code>在一个函数体内时，则不是顶层。<a href='https://reasonml.chat/t/bucklescript-top-level-declarations/399/3?u=idkjs'>@chenglou</a></p>
</blockquote>

<p>在 Reason 中，每个文件都是一个模块，并且使用关键字 <code>let</code>，<code>type</code> 和 <code>module</code> 在文件顶层定义的所有东西都暴露在其他文件（即其他模块）中使用。在这种情况下，其他模块可以将我们的 repo 类型引用为 RepoData.repo。与 Javascript 不同，不需要导入来引用其他模块的东西。</p>

<p>让我们在 <code>app.re</code> 中使用我们的类型。repos 页面只是 repos 列表，列表中的每个项目都包含 repos 名称（链接到 Github 上的 repos）以及 repos 的 stars 数量。我们将定义一些虚拟数据，并在 <code>App.re</code> 中绘制一个名为 RepoItem 的新组件来表示 repos 列表中的项目：</p>

<pre><code class="language-ocaml">// App.re
let component = ReasonReact.statelessComponent(&quot;App&quot;);

let make = (_children) =&gt; {
    ...component,
    render:(_self) =&gt; {
        /* our dummy data */
        let dummyRepo: RepoData.repo = {
            stargazers_count: 27,
            full_name: &quot;jsdf/reason-react-hacker-news&quot;,
            html_url: &quot;https://github.com/jsdf/reason-react-hacker-news&quot;
        };

        &lt;div className=&quot;App&quot;&gt;
            &lt;h1&gt;{ReasonReact.stringToElement(&quot;Reason Projects&quot;)}&lt;/h1&gt;
            &lt;RepoItem repo=dummyRepo /&gt;
        &lt;/div&gt;
    }
};</code></pre>

<p>在声明开始 <code>let dummyRepo: RepoData.repo = {...}</code>，<code>dummyRepo</code> 是我们正在定义的常量的名称， <code>RepoData.repo</code> 是我们注释它的类型，它来自我们在其中定义它的位置 <code>RepoData.re</code>。请记住，该模块在项目的任何地方都可用。Reason 可以推断出我们声明的大部分事物的类型，但是在这里包含注释是很有用的，这样类型分析者可以告诉我们我们的测试数据是否犯了错误。</p>

<h2 id='reason_中的返回值'>Reason 中的返回值</h2>

<p>请注意，渲染函数的主体现在包含在 <code>{}</code> 括号中，因为它包含多个语句。在 Javascript 中，如果我们在 <code>=&gt;</code> 箭头函数的主体周围使用大括号，我们需要添加一个返回语句来返回一个值。然而在 Reason 中，函数返回最后一条语句产生的值，这里：</p>

<pre><code class="language-ocaml">···
&lt;div className=&quot;App&quot;&gt;
    &lt;h1&gt;{ReasonReact.stringToElement(&quot;Reason Projects&quot;)}&lt;/h1&gt;
    &lt;RepoItem repo=dummyRepo /&gt;
&lt;/div&gt;</code></pre>

<p>自动成为返回值。如果你不想从函数返回任何东西，你可以创建最后一个语句 ()（在 <a href='https://reasonml.github.io/docs/en/function.html#optional-labeled-arguments'>Reason</a> 中称为 “unit”）。</p>

<h2 id='在_reasonreact_中定义组件'>在 ReasonReact 中定义组件</h2>

<p>你现在可能会看到一个错误提示，说 RepoItem 文件或模块没有找到。这是因为我们在App组件渲染函数中添加了 <code>&lt;RepoItem repo=dummyRepo /&gt;</code>，但是我们还没有创建该模块。添加一个名为 <code>RepoItem.re</code> 的新文件，包含：</p>

<pre><code class="language-ocaml">let component = ReasonReact.statelessComponent(&quot;RepoItem&quot;);

let make = (~repo: RepoData.repo, _children) =&gt; 
{
    ...component,
    render: (_self) =&gt;
    &lt;div&gt;{ReasonReact.string(repo.full_name)}&lt;/div&gt;
};</code></pre>

<p>这里发生了什么？让我们来剖析这个文件中发生了什么。</p>

<p>每个 Reason React 组件都是一个 Reason 模块，它定义了一个名为 make 的函数，它定义了 props 和 children 参数。props 被指定为<a href='https://reasonml.github.io/docs/en/function.html#labeled-arguments'>标签参数</a>。</p>

<pre><code class="language-ocaml">let compoent = ReasonReact.statelessComponent(&quot;SomeComponent&quot;);

let make = (~someProp, ~anotherProp, _children) =&gt; /* some stuff here */;</code></pre>

<p><code>make</code> 函数返回一条记录。此记录中的第一件事通常是 <code>...component</code>，其中 <code>component</code> 是<code>ReasonReact.reducerComponent</code> 或 <code>ReasonReact.statelessComponent</code> 的返回值（对于分别使用状态和不使用状态的组件）。如果这看起来有点奇怪，可以把它看作是从 React组件类继承的，就像做 Foo 类的扩展等同于在ReactJS中扩展 <code>class Foo extends React.Component {...</code> 一样。</p>

<pre><code class="language-ocaml">// RepoItem.re
let component = ReasonReact.statelessComponent(&quot;RepoItem&quot;);

let make = (~someProp, ~anotherProp, _children) =&gt; 
    {
        ...component,
        /* render and lifecycle methods go here */
    };</code></pre>

<p>记录的其余部分是您可以从 React 中添加渲染函数和您习惯使用的生命周期方法的位置。</p>

<p>因此，回到 <code>RepoItem.re</code>：</p>

<pre><code class="language-ocaml">let compoent = ReasonReact.statelessComponent(&quot;RepoItem&quot;);

let make = (~repo: RepoData.repo, _children) =&gt;
    {
        ...component,
        render: (_self) =&gt;
        &lt;div&gt;{ReasonReact.stringToElement(repo.full_name)}&lt;/div&gt;
    }</code></pre>

<p>我们这里有一个 <code>stateless component</code> (无状态的组件)，它接受一个名为repo的属性（注解 RepoData 模块中的类型回购），并渲染一个 div。</p>

<p>在ReactJS中，你可以使用 this.props 来访问render方法中的组件的属性。在 ReasonReact 中，我们接收属性作为 make 函数的标签参数，我们可以直接在渲染函数中使用它们（就像我们正在访问上面的 repos 属性的 full_name 字段一样）。</p>

<p>make 函数也会传递一个 children 参数，但我们并没有在这个组件中使用子元素，所以我们在 <em>children 参数名称的开始处放置了一个</em> 下划线。这只是让 Reason 知道我们并没有真正使用这个参数。尽管我们没有使用这个参数，但它仍然需要包含在函数参数中，否则会出错。</p>

<p>接下来，我们将充实渲染函数以呈现 repos 记录的字段：</p>

<pre><code class="language-ocaml">let component = ReasonReact.statelessComponent(&quot;RepoItem&quot;);

let make = (~repo: RepoData.repo, _children) =&gt;
    {
        ...component,
        render: (_self) =&gt;
            &lt;div className=&quot;RepoItem&quot;&gt;
                &lt;a href=repo.html_url&gt;
                    &lt;h2&gt;{ReasonReact.string(repo.full_name)}&lt;/h2&gt;
                &lt;/a&gt;
                {ReasonReact.string(string_of_int(repo.stargazers_count) ++ &quot; stars&quot;)}
            &lt;/div&gt;
    };</code></pre>

<p>请注意，我们必须使用 string<em>of</em>int 函数将 repo.stargazers_count 的 int 值转换为一个字符串。然后我们使用++字符串连接运算符将它与字符串 “stars” 结合起来。</p>

<p>现在是保存并查看浏览器进度的好时机。</p>

<p><img src='/images/1_rVw1dhPmkJ_cyT63uDbN0g.png' alt='1_rVw1dhPmkJ_cyT63uDbN0g' /></p>

<h2 id='有状态的_react_组件又名_reducercomponent_和_variants'>有状态的 React 组件又名 reducerComponent 和 Variants</h2>

<p>我们的应用程序将加载一些数据然后渲染它，这意味着我们需要一个地方来加载数据。 React 状态组件似乎是一个明显的选择。所以我们会让我们的应用组件成为有状态的。我们通过将 <code>ReasonReact.statelessComponent</code> 更改为 <code>ReasonReact.reducerComponent</code> 来完成此操作。</p>

<p>在 <code>App.re</code>：</p>

<pre><code class="language-ocaml">type state = {
    repoData: option(RepoData.repo)
};

/* 我们的虚拟数据 */

let dummyRepo: RepoData.repo = {
    stargazers_count: 27,
    full_name: &quot;jsdf/reason-react-hacker-news&quot;,
    html_url: &quot;https://github.com/jsdf/reason-react-hacker-news&quot;,
};

let repoItem = (repoData: option(RepoData.repo)) =&gt;
    switch (repoData) {
        | Some(repo) =&gt; &lt;RepoItem repo /&gt;
        | None =&gt; ReasonReact.string(&quot;Loading&quot;)
    };

let make = _children =&gt; {
    ...component,
    initialState: () =&gt; {
        repoData: Some(dummyRepo)
    },

    reducer: ((), _) =&gt; ReasonReact.NoUpdate,

    render: ({state:{repoData}}) =&gt;
        &lt;div className=&quot;App&quot;&gt;
            &lt;h1&gt; (ReasonReact.string(&quot;Decoding JSON in ReasonReact&quot;)) &lt;/h1&gt;
            (repoItem(repoData))
        &lt;/div&gt;,
};</code></pre>

<p>我们改变了一些关键的东西：我们已经为使用 Reason 的内置 option Variant 类型的组件状态定义了一个类型。这里简单地称为 <code>state</code>，<code>ReasonReact.statelessComponent</code> 已经成为 <code>ReasonReact.reducerComponent</code>，我们已经为组件添加了一个 <code>initialState</code> 函数，并且我们已经改变了渲染以将自身作为参数（删除 _ 下划线以便自 self 不再被忽略 ），现在正在使用 <code>{state：{repoData}</code> 作为 RepoItem 的属性。什么？！！以下语法称为解构。我们现在正在访问的 <code>self</code> 方法有一个 <code>state</code> 属性，并且使用 <code>{state:...}</code>我们说从上面的第22行开始使用它的状态。</p>

<h2 id='变体！选项'>变体！选项</h2>

<p>我们将我们的 <code>state</code> 类型定义为：</p>

<pre><code class="language-ocaml">type state = {
    repoData: option(RepoData.repo)
};</code></pre>

<p>Reason 中 <code>option</code> 是由 “变体” 组成的类型。这基本上意味着这种类型的值可以是已经明确定义的几种可能变化中的一种。在 <code>option</code> 的情况下，变体是 <code>Some</code> 和 <code>None</code> 。<code>Some</code> 用于存在值（并且包含值本身），而 <code>None</code> 表示没有值（如 Javascript 中的 <code>null</code> ）。在这里，我们&#8217;包裹&#8217; dummyRepo  在 <code>Some</code> 变体中，因为我们有一个值。</p>

<p>该 <code>option</code> 告诉我们（和编译器），该 <code>state</code> 可以是 <code>Some</code> 或 <code>None</code> 的任何值。所以当我们使用这种类型时会有 <code>Some(RepoData.repo)</code> 或 <code>None</code> 。</p>

<p>那么为什么使用这个包装器，而不是让我们的 <code>repoData</code> 字段包含一个值或 null ？Reason 迫使我们在实际使用价值时处理两种可能的情况。这很好，因为这意味着我们不会意外忘记处理&#8217;null（空）&#8217;情况。请注意，在调用 <code>ReasonReact.reducerComponent</code> 之前，必须定义 <code>state</code> 类型，否则会出现类似“类型构造函数状态将脱离其作用域”的错误。我们将通过创建一个名为 <code>repoItem</code> 的变量来告诉组件在每种情况下应该做什么，并定义在类型状态下定义的变例中我们想要发生的事情。</p>

<h2 id='选项和模式匹配'>选项和模式匹配</h2>

<p>当我们定义组件的初始状态时，目前我们已经有了 <code>repoData</code> 伪数据，但是一旦我们从服务器加载它，它的初始值将为空。但是，在 Reason 中，您不能像记录 Javascript 那样只是将记录字段的值设为 <code>null</code>。相反，可能不存在的事物需要用称为 <code>option</code> 的另一种类型“包装”。我们可以改变我们的状态类型来表示如下：</p>

<pre><code class="language-ocaml">type state = {repoData: option(RepoData.repo)};</code></pre>

<p>并且在我们的 <code>initialState</code> 函数中，我们将我们的 <code>repo</code> 记录包装在 <code>Some()</code> 中：</p>

<pre><code class="language-ocaml">initialState: () =&gt; {
    repoData: Some(dummyRepo),
}</code></pre>

<p>在上面的代码中，我们使用 <code>Some</code> 和 <code>None</code> 变体来定义一个 <code>repoItem</code>，如果有一些数据，我们将这些数据传递给我们的 <code>&lt;RepoItem /&gt;</code> 模块，并将它返回给我们组件中的 UI。如果没有数据，我们告诉该函数使用None选项，返回一个 <code>div </code>来呈现 “Loading” 到 UI。</p>

<p>然后在渲染 <code>div</code> 中，我们传递当前的 <code>repoData</code> ，然后传递给 <code>renderItem</code> 函数来处理在每种情况下要做的操作 <code>Some</code> 或 <code>None</code> 。我们无法直接将 <code>state.repoData</code> 作为 <code>RepoItem</code> 的 <code>repo</code> 的属性，因为它被包装在一个 <code>option()</code> 中，但是 <code>RepoItem</code> 期待它没有选项包装。那么我们如何解开它呢？我们使用模式匹配。这是 <code>Reason</code> 用来涵盖所有可能的情况（或者至少明确地抛出错误）的地方。模式匹配使用 <code>switch</code> 语句。然而，与 Javascript 中的 <code>switch</code> 语句不同，reason 中的 <code>switch</code> 语句可以匹配值的类型（例如 <code>Some</code> 和 <code>None</code> ），而不仅仅是值本身。我们将改变我们的渲染方法，使用 <code>switch</code> 在每种可能的情况下提供逻辑来呈现我们的 <code>repo</code> 项目。我们可以通过创建一个函数 <code>renderItem</code> 来处理每个 <code>case</code> 并根据结果进行渲染。</p>

<pre><code class="language-ocaml">repoItem = (repoData: option(RepoData.repo)) =&gt; 
    switch (repoData) {
        | Some(repo) =&gt; &lt;RepoItem repo /&gt;
        | None =&gt; ReasonReact.string(&quot;Loading&quot;)
    };</code></pre>

<p>在这里你可以看到 <code>switch</code> 语句有一个 <code>case</code> 与 <code>state.repoData</code> 类型的 <code>Some</code> 类型匹配，并且将实际的 <code>repo</code> 记录提取到一个名为 <code>repo</code> 的变量中，然后它将它用在 =&gt; 右边的表达式中， 返回一个 &lt;RepoItem&gt; 元素。这个表达式只会在 <code>state.repoData</code> 是 <code>Some</code> 的情况下使用。或者，如果 <code>state.repoData</code> 为 <code>None</code>，则将显示文本 “Loading”。</p>

<p>我们将在我们的 div 中调用 repoItem 并将它作为 repoData 解构的 state.repoData。</p>

<pre><code class="language-ocaml">render: ({state: {repoData}}) =&gt; 
    &lt;div className=&quot;App&quot;&gt;
        &lt;h1&gt; (ReasonReact.string(&quot;Decoding JSON in ReasonReact&quot;)) &lt;/h1&gt;
        (repoItem(repoData))
    &lt;/div&gt;,</code></pre>

<p>如果您运行 <code>yarn start</code> 开始，您应该在浏览器中看到与以前相同的输出：</p>

<p><img src='/images/1_rVw1dhPmkJ_cyT63uDbN0g.png' alt='1_rVw1dhPmkJ_cyT63uDbN0g' /></p>

<h2 id='reducer_components'>Reducer Components</h2>

<p>那么，为什么 Reason React 中的有状态组件类型称为 reducerComponent ？与 ReactJS 相比，ReasonReact 处理组件状态更改的方式略有不同。如果你已经使用 <a href='https://redux.js.org/'>Redux</a> ，它会看起来很熟悉。如果你还没有，不要担心，这里不需要背景知识。</p>

<p>基本上，不是像 onClick 那样在事件处理程序中做一堆事情然后调用 <code>this.setState</code> ，我们只需要知道我们想要对组件状态做出什么样的改变，然后调用 <code>self.send</code> 一个“ <code>action</code> ”，它只是一个表示应该发生的状态更改的值，以及我们需要更改的任何信息。这意味着大部分状态变化代码都可以用纯函数隔离，这使得它更容易跟踪，并且更容易编写测试。</p>

<p>我们可以尝试通过这种方式进行状态更改，方法是首先将 <code>state</code> 设置为 <code>None</code> ，然后在用户单击按钮后更改状态。这是一个人为的例子，但它对说明状态变化很有用。点击此按钮后，假设我们正在从API加载数据:)。</p>

<p>首先，我们需要添加一个名为 <code>action</code> 的类型，它列举了可能发生在我们组件中的各种可能的状态变化。现在只有一个：<code>Loaded</code>，用于加载 repo 数据时：</p>

<pre><code class="language-ocaml">type action = 
    | Loaded(RepoData.repo);</code></pre>

<p>之后，我们添加一个 <code>reducer</code> 方法，它接受一个这样的动作和当前状态，然后计算并返回更新的状态：</p>

<pre><code class="language-ocaml">reducer = (action, _state) =&gt; 
    switch (action) {
        | Loaded(loadedRepo) =&gt;
            ReasonReact.Update({
                repoData: Some(loadedRepo)
            })
    };</code></pre>

<p>您可以看到，我们的实现是对动作类型进行模式匹配并返回包含新状态的 <code>ReasonReact.Update</code>。现在我们只是为 <code>Loaded</code> 行动提供一个案例，但在未来，我们可以想象在这里实施其他类型的状态更改，以响应不同的 <code>action</code> 变体。</p>

<p>接下来我们更改 <code>initialState</code> ，以无 repo 数据开始：</p>

<pre><code class="language-ocaml">initialState: () =&gt; {
    repoData: None
},</code></pre>

<p>最后，我们在渲染函数中添加一个按钮元素。我们使用 <code>self.send</code> 方法添加到我们的解构对象中，为按钮的 <code>onClick</code> <code>prop</code> 创建一个处理函数。</p>

<p><code>send</code> 采取点击事件调用我们想要使用的动作和它期望的任何值。在这里，<code>send(Loaded(dummyRepo))</code>，将点击转换为我们 <code>reducer</code> 的动作。像这样的处理程序也可以使用来自 <code>click</code> 事件对象的信息，但在这种情况下我们不需要它，所以我们把下划线 <code>_</code> 放在它之前忽略它。我们可以创建这样一个按钮：</p>

<pre><code class="language-ocaml">&lt;button onClick=(_event =&gt; send(Loaded(dummyRepo)))&gt;
    (ReasonReact.string(&quot;Load Repos&quot;))
&lt;/button&gt;</code></pre>

<p>我们可以显示一条消息，在初始空白状态下（当 <code>state.repoData</code> 为 <code>None</code> 时）点击按钮来代替呈现的 <code>RepoItem</code> ：</p>

<pre><code class="language-ocaml">repoItem = (repoData: option(RepoData.repo)) =&gt; 
    switch (repoData) {
        | Some(repo) =&gt; &lt;RepoItem repo /&gt;
        | None =&gt; ReasonReact.string(&quot;Click Button To Load&quot;)
    };</code></pre>

<p>与在 JS React 中调用 <code>setState</code> 相比，使用 <code>action</code> 和 <code>reducer</code> 的额外步骤似乎过于复杂，但随着有状态组件的增长并具有更多可能的状态（它们之间可能存在越来越多的转换），组件很容易成为难以跟踪和无法测试的纠结。 这是 <code>action-reducer</code> 模型真正闪耀的地方。</p>

<p>您可以在 <a href='https://github.com/idkjs/decoding-json-in-reason-react/tree/render-button-detour'>render-button-detour</a> 附带的 repo 中看到此版本的代码。</p>

<p>好，现在我们知道如何进行状态更改，让我们把它变成一个更现实的应用程序。</p>

<h2 id='使用数组与单个_repo'>使用数组与单个 Repo</h2>

<p>在我们从 JSON 加载数据之前，还需要对组件进行一次更改。我们实际上想要显示 repo 列表，而不仅仅是一个清单，所以我们需要改变我们的状态类型：</p>

<pre><code class="language-ocaml">type state = {
    repoData: option(array(RepoData.repo))
};</code></pre>

<p>并对我们的虚拟数据进行相应的更改：</p>

<pre><code class="language-ocaml">dummyRepos: array(RepoData.repo) = [|
  {
    stargazers_count: 27,
    full_name: &quot;jsdf/reason-react-hacker-news&quot;,
    html_url: &quot;https://github.com/jsdf/reason-react-hacker-news&quot;
  },
  {
    stargazers_count: 93,
    full_name: &quot;reasonml/reason-tools&quot;,
    html_url: &quot;https://github.com/reasonml/reason-tools&quot;
  }
|];</code></pre>

<p>呃，<code>[| ... |]</code> 语法？这是 Reason 的数组字面量语法。如果你没有 <code>|</code> 管道字符（所以它看起来像正常的 JS 数组语法），那么你会定义一个 <code>List</code> 而不是一个数组。在 Reason 中列表是不可变的，而数组是可变的（如 Javascript 数组），但是如果处理可变数量的元素，则列表更容易处理。无论如何，我们正在使用一个数组。</p>

<p>我们需要查看代码并将所有引用 <code>repoData</code>  的地方都改为 <code>RepoData.repo</code>，而不是指定 <code>array(RepoData.repo)</code>。</p>

<p>最后，通过映射 <code>repos</code> 数组并为每个 <code>RepoItem</code> 创建一个 <code>&lt;RepoItem /&gt;</code>，我们将改变渲染方法来渲染一个 <code>RepoItem</code> 数组而不是一个。 我们必须使用 <code>ReasonReact.array</code> 将元素数组转换为元素本身，以便它可以在下面的 JSX 中使用。</p>

<pre><code class="language-ocaml">repoItems = (repoData: option(array(RepoData.repo))) =&gt;
    switch (repoData) {
        | Some(repo) =&gt;
            ReasonReact.array(
                Array.map(
                    (repo: RepoData.repo) =&gt; &lt;RepoItem key=repo.full_name repo /&gt;,
                    repos,
                ),
            )
        | None =&gt; ReasonReact.string(&quot;Loading&quot;)
    };

let make = _children =&gt; {
    ...component,

    initialState: () =&gt; {
        repoData: Some(dummyRepos)
    },

    reducer: ((), _) =&gt; ReasonReact.NoUpdate,

    render: ({state: {repoData}}) =&gt;
        &lt;div className=&quot;App&quot;&gt;
            &lt;h1&gt; (ReasonReact.string(&quot;Decoding JSON in ReasonReact&quot;)) &lt;/h1&gt;
            (repoItems(repoData))
        &lt;/div&gt;,
};</code></pre>

<p>我在 <code>repo</code> 中标记了代码的各个部分。所以在这一点上，你可以检查 <a href='https://github.com/idkjs/decoding-json-in-reason-react/tree/setting-up-arrays'>`setting-up-arrays tag`</a>。</p>

<p>现在，加载一些真实的数据。</p>

<h2 id='bucklescript'>BuckleScript</h2>

<p>在获取我们的 JSON 并将其转换为记录之前，首先我们需要安装一些额外的依赖关系。运行：</p>

<pre><code class="language-ocaml">npm install --save bs-fetch @glennsl/bs-json</code></pre>

<p>或者</p>

<pre><code class="language-ocaml">yarn add bs-fetch @glennsl/bs-json</code></pre>

<p>以下是这些包的作用：<a href='https://github.com/reasonml-community/bs-fetch'>`bs-fetch`</a>：包装浏览器获取 API，以便我们可以从 Reason <a href='https://github.com/glennsl/bs-json'>`@glennsl/bs-json`</a> 中使用它：允许使用将从服务器获取的 JSON 转换为 Reason 记录。</p>

<p>这些包与我们一直使用的 Reason-to-JS 编译器一起工作，这就是所谓的 <a href='https://bucklescript.github.io/'>BuckleScript</a> 。</p>

<p>在我们可以使用这些新安装的 BuckleScript 包之前，我们需要让 BuckleScript 知道它们。为此，我们需要对项目根目录下的 <code>.bsconfig</code> 文件进行一些更改。在 <code>bs-dependencies</code> 部分中，添加 <code>bs-fetch</code> 和 <code>bs-json</code>：</p>

<pre><code class="language-ocaml">{
&quot;name&quot;: &quot;reason-scripts&quot;,
&quot;sources&quot;: [&quot;src&quot;],
&quot;bs-dependencies&quot;: [
    &quot;reason-react&quot;,
    &quot;bs-jest&quot;,&quot;bs-fetch&quot;, // add this
    &quot;@glennsl/bs-json&quot; // and this too
],
// ...more stuff</code></pre>

<p>您需要终止并重新启动 <code>yarn start</code> / <code>npm start</code> 命令，以便构建系统可以获取对 <code>.bsconfig</code> 的更改。</p>

<h2 id='读取_json'>读取 JSON</h2>

<p>现在我们已经安装了 <code>bs-json</code>，我们可以使用 <code>Json.Decode</code> 来读取 JSON 并将其转化为记录。</p>

<p>我们将在 <code>RepoData.re</code> 的末尾定义一个名为 <code>parseRepoJson</code> 的函数：</p>

<pre><code class="language-ocaml">// RepoData.re

type repo = {
    full_name: string,
    stargazers_count: int,
    html_url: string
};

let parseRepoJson = (json: Js.Json.t): repo =&gt; {
    full_name: Json.Decode.field(&quot;full_name&quot;, Json.Decode.string, json),
    stargazers_count: Json.Decode.field(&quot;stargazers_count&quot;, Json.Decode.int, json),
    html_url: Json.Decode.field(&quot;html_url&quot;, Json.Decode.string, json)
}</code></pre>

<p>我们定义了一个名为 <code>parseRepoJson</code> 的函数，它接受一个名为 <code>json</code> 的参数并返回 <code>RepoData.repo</code> 类型的值。<code>Json.Decode</code> 模块提供了一组函数，我们将它们组合在一起来提取 JSON 的字段，并确保我们得到的值是正确的类型。</p>

<h2 id='不要重复自己'>不要重复自己</h2>

<p>这看起来有点罗嗦。我们是否真的必须一遍又一遍地写 <code>Json.Decode</code> ？</p>

<p>不，Reason 有一些方便的语法来帮助我们，当我们需要一次又一次地引用特定模块的输出时。一种选择是“打开”模块，这意味着它的所有输出在当前作用域都可用，所以我们可以抛弃 <code>Json.Decode</code> 限定符：</p>

<pre><code class="language-ocaml">Json.Decode;

let parseRepoJson = (json: repo) =&gt;
{
    full_name: field(&quot;full_name&quot;, string, json),
    stargazers_count: field(&quot;stargazers&quot;, int, json),
    html_url: field(&quot;html_url&quot;, string, json)
};</code></pre>

<p>但是，如果打开多个模块，这会引起名称冲突的风险。另一种选择是使用模块名称，后跟一个句点<code>.</code>在表达之前。在表达式内部，我们可以使用模块的任何导出，而不用模块名称进行限定：</p>

<pre><code class="language-ocaml">let parseRepoJson = (json: Js.Json.t): repo =&gt;
Json.Decode.{
    full_name: field(&quot;full_name&quot;, string, json),
    stargazers_count: field(&quot;stargazers_count&quot;, int, json),
    html_url: field(&quot;html_url&quot;, string, json),
};</code></pre>

<p>注意 <code>(json: Js.Json.t):repo</code>。在这里，我们输入预期的 json 值作为 <code>Js.Json.t</code>，也就是说传入的 <code>repo</code> <code>json</code> 类型必须是(json:Js.Json.t)。请参阅 <a href='https://twitter.com/@nikgraf'>@nikgraf</a> 的 <a href='https://egghead.io/lessons/reason-type-parameters-in-reason'>egghead系列 Reason 类型参数视频</a> 以了解更多信息。事实上，如果你对Reason感兴趣并且没有看过，现在就去看看，然后再回来。然后每周观看一次，直到你找到它。每次你都会学到一些东西。</p>

<p>现在让我们通过添加一些代码来测试它，该代码定义了一个 JSON 字符串并使用我们的 <code>parseRepoJson</code> 函数来解析它。</p>

<p>在app.re中：</p>

<pre><code class="language-ocaml">dummyRepos: array(RepoData.repo) = [|
    RepoData.parseRepoJson(
        Js.Json.parseExn(
            {js|
                {
                    &quot;stargazers_count&quot;: 93,
                    &quot;full_name&quot;: &quot;reasonml/reason-tools&quot;,
                    &quot;html_url&quot;: &quot;https://github.com/reasonml/reason-tools&quot;
                }
            |js}
        )
    )
|];</code></pre>

<p>不要担心理解什么 <code>Js.Json.parseExn</code> 或奇怪的 <code>{js | ... | js}</code> 的东西（这是一个可选的<a href='https://bucklescript.github.io/bucklescript/Manual.html#_bucklescript_annotations_for_unicode_and_js_ffi_support'>字符串字面量语法</a>）。返回到浏览器，您应该看到从该 JSON 输入成功呈现页面。</p>

<p><img src='/images/1_vJeQUw9FWZBb2lK_muJnaQ.png' alt='1_vJeQUw9FWZBb2lK_muJnaQ.png' /></p>

<p>请参阅 repo 标签 <a href='https://github.com/idkjs/decoding-json-in-reason-react/tree/bs-json-parsing'>bs-json-parsing</a>。</p>

<h2 id='获取数据'>获取数据</h2>

<p>请参阅 <a href='https://github.com/idkjs/decoding-json-in-reason-react/tree/fetching-data'>fetching-data</a></p>

<p>查看 <a href='https://api.github.com/search/repositories?q=topic%3Areasonml&amp;type=Repositories'>Github API 响应</a>的形式，我们对items 字段感兴趣。</p>

<p><img src='/images/1_Tc7TgXVmGv4i_xt4Lz4dxA.png' alt='1_Tc7TgXVmGv4i_xt4Lz4dxA.png' /></p>

<p>该字段包含一个 repos 数组。我们将添加另一个函数，它使用我们的 <code>parseRepoJson</code> 函数将 items 字段解析为一个记录数组。</p>

<p>在 <code>RepoData.re</code>中：</p>

<pre><code class="language-ocaml">parseReposResponseJson = json =&gt; 
    Json.Decode.field(&quot;items&quot;, Json.Decode.array(parseRepoJson), json);</code></pre>

<p>最后，我们将使用 <code>bs-fetch</code> 包来向 API 发送 HTTP 请求。</p>

<p>但首先，更多的新语法！我保证这是最后一点。管道运算符 <code>|&gt;</code> 只是将 <code>|&gt;</code> 运算符左边的表达式的结果取出来，并使用该值调用 <code>|&gt;</code> 运算符右边的函数。</p>

<p>例如，以下代码：</p>

<pre><code class="language-ocaml">(doThing3(doThing2(doThing1(arg))));</code></pre>

<p>通过管道运算符，我们可以做到：</p>

<pre><code class="language-ocaml">arg |&gt; doThing1 |&gt; doThing2 |&gt; doThing3</code></pre>

<p>这让我们可以模拟类似 Javascript 中的 Promises 的链式 API ，不同之处在于 <code>Js.Promise.then_</code> 是我们用 promise 作为参数调用的函数，而不是 promise 对象上的方法。</p>

<p>在 <code>RepoData.re</code> 中：</p>

<pre><code class="language-ocaml">let reposUrl = &quot;https://api.github.com/search/repositories?q=topic%3Areasonml&amp;type=Repositories&quot;;

let fetchRepos = () =&gt; {
    Fetch.fetch(reposUrl)
    |&gt; Js.Promise.then_(Fetch.Response.text)
    |&gt; Js.Promise.then_(
        jsonText =&gt;
            Js.Promise.resolve(parseReposResponseJson(Js.Json.parseExn(jsonText)))
    );
}</code></pre>

<p>我们可以通过暂时打开 <code>Js.Promise</code> 来使 Promise 链式 <code>fetchRepos</code> 更简洁：</p>

<pre><code class="language-ocaml">fetchRepos = () =&gt;
    Js.Promise.(
        Fetch.fetch(reposUrl)
        |&gt; then_(Fetch.Response.text)
        |&gt; then_(
            jsonText =&gt;
                resolve(parseReposResponseJson(Js.Json.parseExn(jsonText)))
        )
    );</code></pre>

<p>最后，回到 <code>App.re</code> 中，我们将添加一些代码来加载数据并将其存储在组件状态中：</p>

<pre><code class="language-ocaml">type state = {
    repoData: option(array(RepoData.repo))
};

type action = 
    | Loaded(array(RepoData.repo));

let component = ReasonReact.reducerComponent(&quot;App&quot;);

let dummyRepos: array(RepoData.repo) = [|
    RepoData.parseRepoJson(
        Js.Json.parseExn(
            {js|
                {
                    &quot;stargazers_count&quot;: 93,
                    &quot;full_name&quot;: &quot;reasonml/reason-tools&quot;,
                    &quot;html_url&quot;: &quot;https://github.com/reasonml/reason-tools&quot;
                }
            |js},
        ),
    ),
|];

let repoItems = (repoData: option(array(RepoData.repo))) =&gt;
    switch (repoData) {
        | Some(repos) =&gt;
            ReasonReact.array(
                Array.map(
                    (repo: RepoData.repo) =&gt; &lt;RepoItem key=repo.full_name repo /&gt;,
                    repos,
                ),
            )
        | None =&gt; ReasonReact.string(&quot;Loading&quot;)
    };

let reducer = (action, _state) =&gt; 
    switch (action) {
        | Loaded(loadedRepo) =&gt; ReasonReact.Update({
            repoData: Some(loadedRepo)
        })
    };

let make = _children =&gt; {
    ...component,
    initialState: () =&gt; {
        repoData: None
    },

    didMount: self =&gt; {
        let handleReposLoaded = repoData =&gt; self.send(Loaded(repoData));

        RepoData.fetchRepos()
        |&gt; Js.Promise.then_(repoData =&gt; {
                handleReposLoaded(repoData);
                Js.Promise.resolve();
            })
        |&gt; ignore;
    },

    reducer,

    render: ({state: {repoData}}) =&gt;
        &lt;div className=&quot;App&quot;&gt;
            &lt;h1&gt; (ReasonReact.string(&quot;Decoding JSON in ReasonReact&quot;)) &lt;/h1&gt;
            (repoItems(repoData))
        &lt;/div&gt;,
};</code></pre>

<p>首先我们实现 <code>didMount</code> 生命周期方法。我们使用 <code>self.send</code> 创建一个名为 <code>handleReposLoaded</code> 的函数来处理我们加载的数据并更新组件状态。我们将在我们的 <code>RepoData.fetchRepos()</code> 函数中调用它，并将它传递给期望的 <code>repoData</code> 值。 <code>handleReposLoaded</code> 然后将该值传递给 <code>self.send</code>，我们将它传递给定义的 <code>action</code> 类型。<strong>*self.send 与 <code>action</code> 类型一起使用以便使用它，请确保您已经定义了要使用它的 <code>action</code> 。</strong>* 因此，使用我们的 <code>RepoData.fetchRepos()</code> 函数，我们加载数据。就像 Javascript中的链式 Promise ，我们将其传递到 <code>Js.Promise.then_</code> 中，在那里我们用加载的数据调用 <code>handleReposLoaded</code> 函数，更新组件状态。</p>

<p>我们通过返回 <code>Js.Promise.resolve()</code> 来结束 promise 链。定义 promise 链的整个表达式然后 <code>|&gt;</code> 传送到一个称为 <code>ignore</code> 的特殊函数，它只是告诉 Reason 我们不打算对 promise 链表达式计算的值做任何事情（我们只关心副作用 它具有调用更新函数的功能）。</p>

<p>这就是它在浏览器中的样子：</p>

<p><img src='/images/1_lYil0QkDtiH1PQLDrXvg3g.png' alt='1_lYil0QkDtiH1PQLDrXvg3g.png' /></p>

<h2 id='添加一些_css'>添加一些 CSS</h2>

<p>让我们回到 <code>index.re</code>。将此代码添加到文件的顶部：</p>

<pre><code class="language-ocaml">[%bs.raw {|
require(&#8217;./index.css&#8217;);
|}];</code></pre>

<p>这<code>%bs.raw</code> 的东西允许我们在 <code>{|</code> 和 <code>|}</code> 之间加入一些简单的 Javascript 代码。在这种情况下，我们只是使用它来以通常的 Webpack 方式包含一个 CSS 文件。保存后，您应该看到应用于应用的一些样式更改。您可以打开为我们制作的 <code>create-react-app</code> 的 <code>index.css</code> 文件，并根据您的内容定制样式。让我们添加一些 <code>margin</code>，以便 ui 不会被推到左侧。打开 <code>index.css</code> 并将其更改为：</p>

<pre><code class="language-ocaml">{
    margin:2em;
    padding:0;
    font-family: sans-serif;
}</code></pre>

<p>您还可以通过传递使用 <a href='https://reasonml.github.io/reason-react/docs/en/style.html#docsNav'>`ReactDOMRe.Style.make`</a> 创建的样式属性，在 React 组件中使用内联样式：</p>

<pre><code class="language-ocaml">style={ReactDOMRe.Style.make(~color=&quot;red&quot;, ~fontSize=&quot;68px&quot;)()}</code></pre>

<p>就是这样！</p>

<p>你可以在<a href='https://decoding-json-in-reason-react.netlify.com/'>这里</a>看到完成的应用程序。完整的源代码在 <a href='https://github.com/idkjs/decoding-json-in-reason-react'>Github</a> 上可用。</p>

<h2 id='奖金：使用_netlify_和_git_子树部署_demo。'>奖金：使用 Netlify 和 git 子树部署 Demo。</h2>

<p>然后 <code>yarn build</code> 生成以获得项目的生产版本。</p>

<p>从项目的 <code>.gitignore</code> 文件中删除 <code>build</code> （它由 create-react-app 默认忽略）。</p>

<p>将以下命令添加到 package.json 的脚本键值中：</p>

<pre><code class="language-ocaml">...
    &quot;deploy&quot;: &quot;git subtree push --prefix build origin gh-pages&quot;,
...</code></pre>

<p>确保 git 知道你的子树（你的网站的子文件夹）。运行：</p>

<pre><code class="language-ocaml">add build &amp;&amp; git commit -m &quot;Initial dist subtree commit&quot;</code></pre>

<p>运行 <code>yarn deploy</code>。</p>

<p>如果没有，请注册 Netlify 。登录后，点击大蓝 “Git的新站点” 按钮。</p>

<p>选择您的 repo，将目录更改为您的 gh-pages 目录，然后单击 “Deploy Site” 按钮。</p>

<p><img src='/images/1_UbMYnovAa1GUt0PYsO7x9A.png' alt='1_UbMYnovAa1GUt0PYsO7x9A.png' /></p>

<h2 id='谢谢！'>谢谢！</h2>

<p>如果您对本文有任何反馈，可以发推文给我：<a href='https://www.twitter.com/@_idkjs'>@_idkjs</a>。感谢 <a href='https://www.twitter.com/@ur_friend_james'>@ur_friend_james</a> 的原始帖子，可以在<a href='https://jamesfriend.com.au/a-first-reason-react-app-for-js-developers'>这里</a>找到。</p>
