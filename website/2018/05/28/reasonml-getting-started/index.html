<!--
 * @Author: Leland
 * @Date: 2019-12-27 15:59:00
 * @Description: Description
 -->
<!doctype html>
<html>

    <head>
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui" />
        <title>ReasonML 入门</title>
        <link href="/css/style.css" rel="stylesheet" />
        <meta name="description" content="ReasonML 入门">
    </head>

    <body>
        <div>
        <div>
        <header class="header">
            <div class="container header-wrap">
                <h1 class="site-name">
                    <a href="/">
                        首页
                    </a>
                </h1>
                <ul class="nav">
                    {{navs}}
                </ul>
            </div>
        </header>
        </div>
        <div class="container main">
        <div class="page-body">
            <div class="markdown-body">
                <h1>ReasonML 入门</h1>
<p>译自： https://dev.to/jlewin_/reasonml-getting-started-53gi</p>
<p>在本教程中，我们将使用Reason构建一个小型天气应用程序。有一个链接到页面底部的源代码。本教程假设您对React有基本的了解，因为我们将使用ReasonReact绑定来构建应用程序。如果您以前没有使用过 React，那么<a href="https://dev.to/tylermcginnis/a-comprehensive-guide-to-reactjs-in-2018--4nbc">这篇文章</a>是一个很好的开始。</p>
<h2>什么是 Reason</h2>
<p>Reason 是 OCaml 的新语法，由 Facebook 开发，受 JavaScript 影响很大。它有 100％ 的类型覆盖率，这导致了一个非常强大的类型系统。</p>
<p>Reason 也适用于跨平台开发。我们可以使用 BuckleScript 将我们的代码编译成（可读的）JavaScript，从而打开整个 Web 平台。感谢 OCaml，它也可以使用 Reason 进行本地开发。</p>
<p>此外，Reason 还可以访问整个 JS 和 OCaml 生态系统，并提供 ReasonReact 以使用 ReactJS 构建 UI 组件。文档中有一个<a href="https://reasonml.github.io/docs/en/what-and-why.html">有用的页面</a>，可以更详细地解释优势！</p>
<h2>要求</h2>
<p>首先，让我们确保我们安装了正确的工具。</p>
<p>我们将使用 Create React App 引导项目。如果您之前没有使用过，请通过运行 <code>npm i -g create-react-app</code> 进行安装。还有两个我们需要开始的软件包：</p>
<ul>
<li>Reason CLI: Reason 工具链。<a href="https://github.com/reasonml/reason-cli#1-choose-your-platform">检查安装文档</a>。</li>
<li>在撰写本文时，macOS用户可以通过运行 <code>npm i -g reason-cli@3.1.0-darwin</code>。</li>
<li>BuckleScript: <code>npm i -g bs-platform</code>。</li>
</ul>
<p>我也使用 <a href="https://github.com/reasonml-editor/vscode-reasonml">vscode-reasonml</a> 编辑器插件。如果您使用的是其他编辑器，请检查<a href="https://reasonml.github.io/docs/en/editor-plugins.html">插件列表</a>以找到适合您的插件。</p>
<h2>我们的第一个组件</h2>
<p>要开始，我们将为我们的应用程序创建样板代码：</p>
<p><code>create-react-app weather-app --scripts-version reason-scripts</code></p>
<p>这给了我们一个基本的 App 组件：</p>
<pre><code class="language-ocaml">[%bs.raw {|require('./app.css')|}];

[@bs.module] external logo : string = &quot;./logo.svg&quot;;

let component = ReasonReact.statelessComponent(&quot;App&quot;);

let make = (~message, _children) =&gt; {
    ...component,
    render: (_self) =&gt;
        &lt;div className=&quot;App&quot;&gt;
            &lt;div className=&quot;App-header&quot;&gt;
                &lt;img src=logo className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;
                &lt;h2&gt; (ReasonReact.stringToElement(message)) &lt;/h2&gt;
            &lt;/div&gt;
            &lt;p className=&quot;App-intro&quot;&gt;
                (ReasonReact.stringToElement(&quot;To get started, edit&quot;))
                &lt;code&gt; (ReasonReact.stringToElement(&quot; src/app.re &quot;)) &lt;/code&gt;
                (ReasonReact.stringToElement(&quot;and save to reload.&quot;))
            &lt;/p&gt;
        &lt;/div&gt;
};
</code></pre>
<p>我们可以使用 <code>yarn start</code> 开始编译和运行。我们来看看一些有趣的部分......</p>
<pre><code class="language-ocaml">[%bs.raw {|require('./app.css')|}];
</code></pre>
<p>BuckleScript 允许我们将原始的 JavaScript 代码混合到我们的代码中，从一个一行代码到一个完整的库(如果我们只是在 hacking)。这应该很少使用，但是在我们开始的时候可以快速开始。</p>
<pre><code class="language-ocaml">let component = ReasonReact.statelessComponent(&quot;App&quot;);
</code></pre>
<p>我们将使用两种类型的ReasonReact组件：<code>statelessComponent</code> 和 <code>reducerComponent</code>。无状态组件按照他们在锡上所说的话做。 Reducer组件是有状态的，并且内置了类似 Redux 的 reducers。 我们稍后再讨论。</p>
<pre><code class="language-ocaml">let make = (~message, _children) =&gt; { ... }
</code></pre>
<p>这是定义我们组件的方法。 这两个参数具有不同的符号：<code>〜</code> 是一个带标签的参数，意味着我们可以通过名称引用参数，而 <code>_</code> 是一种更明确的方式显示参数未被使用（否则编译器会给我们一个警告）。</p>
<p><code>...component</code> 扩展运算符意味着我们的 make 函数正在构建我们刚定义的组件，覆盖默认值。</p>
<pre><code class="language-ocaml">&lt;h2&gt; (ReasonReact.stringToElement(message)) &lt;/h2&gt;
</code></pre>
<p>JSX 中的 Reason 比正常的 React 更严格。我们不能仅仅编写 <code>&lt;h2&gt; {message} &lt;/h2&gt;</code>，而是必须将 <code>message</code> 字符串显式转换为 JSX 元素。</p>
<p>稍后我们将构建自己的组件时，我们将使用此样板。</p>
<h2>Reason 中的类型</h2>
<p>我们创建一个新文件 <code>WeatherData.re</code>。这将为我们的天气记录定义数据结构和任何相关方法。首先，我们来创建一个类型：</p>
<pre><code class="language-ocaml">type weather = {
    summary: string,
    temp: float
};
</code></pre>
<p>在这个文件中，我们可以使用这个数据结构创建新记录，编译器会知道它是一个 Weather 项目。从其他文件中，我们需要告诉编译器该类型是什么。在 Reason 中，<a href="https://reasonml.github.io/docs/en/faq.html#i-don-t-see-any-import-or-require-in-my-file-how-does-module-resolution-work">文件可以作为模块引用</a>，这意味着我们不必显式导入它们！我们可以这样做：</p>
<pre><code class="language-ocaml">let today: WeatherData.weather = {
    summary: &quot;Warm throughout the day&quot;,
    temp: 30.5
};
</code></pre>
<p>我之前提到 Reason 有 100％ 的类型覆盖率，但我们只定义了我们的 Weather 类型......其余覆盖范围从哪里来？我们可以明确地为每个我们使用的变量定义一个类型，例如：<code>let greeting: string = &quot;Hello&quot;</code>;但幸运的是 OCaml 系统可以为我们推断类型。所以，如果我们写 <code>let greeting = &quot;Hello&quot;</code> ;编译器仍然会知道 greeting 是一个字符串。这是 Reason 中的一个关键概念，可确保类型安全。</p>
<h2>保持状态</h2>
<p>回到我们的项目，让我们修改app.re，以便它可以存储我们想要显示的数据。这将涉及：</p>
<ul>
<li>定义我们的状态类型</li>
<li>设置我们的初始状态（目前有一些虚拟数据）</li>
<li>定义可应用于状态的操作(<code>actions</code>)</li>
<li>定义组件的 <code>reducers</code> 来处理这些事件</li>
</ul>
<p><code>Actions</code> 定义了我们可以对操作状态做不同的事情。例如，<code>Add</code> 或 <code>Subtract</code>。 Reducers 是纯粹的函数，它定义了这些动作如何影响状态，就像在 Redux 中一样。他们采取 <code>action</code> 和我们以前的状态作为参数，并返回一个<a href="https://reasonml.github.io/reason-react/docs/en/state-actions-reducer.html#state-update-through-reducer">更新类型</a>。</p>
<pre><code class="language-ocaml">type state = {
    weather: WeatherData.weather
};

type action = 
    | WeatherLoaded(WeatherData.weather);

let component = ReasonReact.reducerComponent(&quot;App&quot;);

let dummyWeather: WeatherData.weather = {
    summary: &quot;Warm throughout the day&quot;,
    temp: 30.5
};

let make = (_children) =&gt; {
    ...component,

    initaState: () =&gt; {
        weather: dummyWeather
    },

    reducer: (action, _prevState) =&gt; {
        switch action {
            | WeatherLoaded(newWeather) =&gt;
              ReasonReact.Update({
                  weather: newWeather
              })
        }
    },

    render: (self) =&gt;
        &lt;div className=&quot;App&quot;&gt;
            &lt;p&gt; (ReasonReact.stringToElement(self.state.weather.summary)) &lt;/p&gt;
        &lt;/div&gt;
};

</code></pre>
<p>这里有两个新的 Reason 概念：变体和模式匹配。</p>
<pre><code class="language-ocaml">type action = 
    | WeatherLoaded(WeatherData.weather);
</code></pre>
<p>这是一个变体：代表不同值的选择的数据结构（像枚举）。变体中的每个案例都必须大写，并且可以选择接收参数。在 ReasonReact 中，<code>action</code> 表示为变体。这些可以与 switch 表达式一起使用：</p>
<pre><code class="language-ocaml">switch action {
    | WeatherLoaded(newWeather) =&gt;
      ReasonReact.Update({...})
}
</code></pre>
<p>这是 Reason 中最有用的功能之一。这里我们是基于我们在 <code>reducer()</code> 方法中接收到的参数的模式匹配 <code>action</code>。如果我们忘记处理一个案例，编译器知道，并会告诉我们！</p>
<p><img src="/images/sfutmltmhu1fmzzjs9zs.png" alt="错误提示例子" />
Reason 编译器捕获未处理的案例。</p>
<p>在前面的例子中，我们使用解构来访问 newWeather 的值。我们也可以使用它来根据它们包含的值匹配 <code>actions</code>。这给了我们一些<a href="https://reasonml.github.io/docs/en/pattern-matching.html">非常强大的行为</a>！</p>
<h2>获取数据</h2>
<p>到目前为止，我们的应用呈现虚拟天气数据 - 现在让我们从 API 中加载它。我们将把获取和解析数据的方法放在我们现有的 WeatherData.re 文件中。</p>
<p>首先，我们需要安装 <a href="https://github.com/reasonml-community/bs-fetch">bs-fetch</a> ：<code>npm i bs-fetch</code> 和 <a href="https://github.com/glennsl/bs-json">bs-json</a>：<code>npm i @glennsl/bs-json</code>。我们还需要将它们添加到我们的 <code>bsconfig.json</code> 中：</p>
<pre><code class="language-ocaml">{
    ...
    &quot;bs-dependencies&quot;: [
        &quot;bs-fetch&quot;,
        &quot;@glennsl/bs-json&quot;
    ]
}
</code></pre>
<p>我们将使用 <a href="https://developer.yahoo.com/weather">Yahoo Weather API</a> 来获取我们的数据。我们的 <code>getWeather()</code> 方法将调用 API，然后使用<code>parseWeatherResultsJson()</code> 解析结果，然后解析天气项目：</p>
<pre><code class="language-ocaml">type weather = {
    summary: string,
    temp: float
};

let url = &quot;https://query.yahooapis.com/v1/public/yql?q=select%20item.condition%20from%20weather.forecast%20where%20woeid%20in%20(select%20woeid%20from%20geo.places(1)%20where%20text%3D%22london%22)%20AND%20u%3D%22c%22&amp;format=json&amp;env=store%3A%2F%2Fdatatables.org%2Falltableswithkeys&quot;;

let parseWeatherJson = json: weather =&gt; 
    Json.Decode.{
        summary: field(&quot;text&quot;, string, json),
        temp: float_of_string(field(&quot;temp&quot;, string, json))
    };

let parseWeatherResultsJson = json =&gt;
    Json.parseOrRaise(json) |&gt; Json.Decode.(at([
        &quot;query&quot;,
        &quot;results&quot;,
        &quot;channel&quot;,
        &quot;item&quot;,
        &quot;condition&quot;
    ], parseWeatherJson));

let getWeather = () =&gt;
    Js.Promise.(
        Bs_fetch.fetch(url)
            |&gt; then_(Bs_fetch.Response.text)
            |&gt; then_(
                jsonText =&gt; {
                    let result = parseWeatherResultsJson(jsonText);
                    resolve(result);
                }
            )
    );

</code></pre>
<pre><code class="language-ocaml">Josn.parseOrRaise(json) |&gt; Json.Decode.(at([
    ...
], parseWeatherJson));
</code></pre>
<p>这会在通过指定字段遍历数据之前解析 JSON 字符串响应。然后它使用 parseWeatherJson() 方法来解析在条件字段中找到的数据。</p>
<pre><code class="language-ocaml">Json.Decode.{
    summary: field(&quot;text&quot;, string, json),
    temp: float_of_string(field(&quot;temp&quot;, string, json))
};
</code></pre>
<p>在这个片段中，字段和字符串是 <code>Json.Decode</code> 的属性。这个新的语法“打开” <code>Json.Decode</code>，所以它的属性可以在大括号内自由使用（而不是重复<code>Json.Decode.foo</code>）。该代码生成一个 <code>weather</code> 项目，使用 <code>text</code> 和 <code>temp</code> 字段分配 <code>summary</code> 和 <code>temp</code>。</p>
<p><code>float_of_string</code> 完全符合你的期望：它将字符串中的温度（从API获得）转换为浮点数。</p>
<h2>更新状态</h2>
<p>现在我们有一个返回 <code>promise</code> 的 <code>getWeather()</code> 方法，我们需要在 App 组件加载时调用它。ReasonReact 对 React.js 有一组类似的生命周期方法，但有一些<a href="https://reasonml.github.io/reason-react/docs/en/lifecycles.html">细微差别</a>。我们将使用 <code>didMount</code> 生命周期方法使 API 调用获取天气。</p>
<p>首先，我们需要改变我们的状态，以表明可能没有状态的天气项目 - 我们将摆脱虚拟数据。 <code>option()</code> 是 Reason 中的一个内置变体，它描述了一个“<code>nullable</code>（可空）”值：</p>
<pre><code class="language-ocaml">type option('a) = None | Some('a);
</code></pre>
<p>我们需要在我们的状态类型和初始状态中指定 <code>None</code>，并在 <code>WeatherLoaded</code> reducer 中指定 <code>Some(weather)</code>：</p>
<pre><code class="language-ocaml">type state = {
    weather: option(WeatherData.weather)
};

// ...

let make = (_children) =&gt; {
    ...component,

    initialState: () =&gt; {
        weather: None
    },

    reducer: (action, _prevState) =&gt; {
        switch action {
            | WeatherLoaded(newWeather) =&gt;
              ReasonReact.Update({
                  weather: Some(newWeather)
              })
        }
    },

    // ...
};
</code></pre>
<p>现在，我们实际上可以在组件装入时发出 API 请求。查看下面的代码，<code>handleWeatherLoaded</code> 是一个将我们的 <code>WeatherLoaded</code> action 分派给 reducer 的方法。</p>
<p>注意：重要的是从大多数组件生命周期中返回 <code>ReasonReact.NoUpdate</code>。reducer 将在下一次改变中处理所有状态变化。</p>
<pre><code class="language-ocaml">let make = (_children) =&gt; {
    // ...

    didMount: (self) =&gt; {
        let handleWeatherLoaded = weather =&gt; self.send(WeatherLoaded(weather));
        WeatherData.getWeather()
            |&gt; Js.Promise.then_(
                weather =&gt; {
                    handleWeatherLoaded(weather);
                    Js.Promise.resolve();
                }
            )
            |&gt; ignore;

            ReasonReact.NoUpdate;
    },

    // ...
};
</code></pre>
<p>如果我们现在运行我们的应用程序，我们会遇到错误...我们当前正在尝试呈现关于 <code>self.state.weather</code> 的信息，但是直到我们收到来自 API 的响应时，它才设置为 None。让我们更新我们的应用程序组件，以便在等待时显示加载消息：</p>
<pre><code class="language-ocaml">let make = (_children) =&gt; {
    // ... 

    render: (self) =&gt; 
        &lt;div className=&quot;App&quot;&gt;
            &lt;p&gt;
            {
                switch self.state.weather {
                    | None =&gt;
                        ReactReact.stringToElement(&quot;Loading weather...&quot;);
                    | Some(weather) =&gt; 
                        ReactReact.stringToElement(weather.summary);
                }
            }
            &lt;/p&gt;
        &lt;/div&gt;
};
</code></pre>
<p>结果...</p>
<p><img src="/images/ezgif-3-cf07dc176b.gif" alt="效果图" /></p>
<h2>错误处理</h2>
<p>我们没有想过的一件事是如果我们无法加载数据会发生什么。如果API停机，或者它返回了我们预料不到的情况呢？我们需要认识到这一点并拒绝承诺：</p>
<pre><code class="language-ocaml">let getWeather = () =&gt;
    Js.Promise.(
        Bs_fetch.fetch(url)
            |&gt; then_(Bs_fetch.Response.text)
            |&gt; then_(
                jsonText =&gt; {
                    switch (parseWeatherResultsJson(jsonText)){
                    | exception e =&gt; reject(e);
                    | weather =&gt; resolve(weather);
                    };
                }
            )
    );
</code></pre>
<pre><code class="language-ocaml">switch (parseWeatherResultsJson(jsonText)) {
    | exception e =&gt; reject(e);
    | weather =&gt; resolve(weather);
};
</code></pre>
<p>这个 switch 语句试图解析 API 响应。如果发生异常，它会拒绝承诺那个错误。如果解析成功，该承诺将与天气项目一起解决。</p>
<p>接下来，我们将改变我们的状态，让我们认识到是否发生错误。我们来创建一个新的类型，它向我们之前的 <code>Some('a)</code> 或 <code>None</code> 添加一个 <code>Error</code> 案例。</p>
<pre><code class="language-ocaml">type optionOrError('a) = 
    | Some('a)
    | None
    | Error;

type state = {
    weather: optionOrError(WeatherData.weather)
};
</code></pre>
<p>在这样做的同时，我们还需要向渲染函数添加一个 <code>Error</code> 案例 - 我会让你自己添加。最后，我们需要创建一个新的 <code>action</code>和 <code>reducer</code>，以便在我们的 <code>getWeather()</code> 承诺被拒绝时使用。</p>
<pre><code class="language-ocaml">// ...
type action = 
    | WeatherLoaded(WeatherData.weather)
    | WeatherError;

let make = (_children) =&gt; {
    ...component,

    didMount: (self) =&gt; {
        let handleWeatherLoaded = weather =&gt; self.send(WeatherLoaded(weather));
        let handleWeatherError = () =&gt; self.send(WeatherError);

        WeatherData.getWeather()
            |&gt; Js.Promise.then_(
                // ...
            )
            |&gt; Js.Promise.catch(
                _err =&gt; {
                    handleWeatherError();
                    Js.Promise.resolve();
                }
            )
            |&gt; ignore;

        ReasonReact.NoUpdate;
    },

    reducer: (action, _prevState) =&gt; {
        switch action {
            | WeatherLoaded(newWeather) =&gt;
                // ...
            | weatherError =&gt;
              ReasonReact.Update({
                  weather: Error
              })
        }
    },

    // ...
}

</code></pre>
<p>这些是我们已经使用过的概念，但让用户知道是否出现了问题是很有用的。我们不想让他们挂着“加载”消息！</p>
<p>我们有它，我们的第一个 ReasonReact 网络应用程序。干得不错！我们已经介绍了很多新的概念，但希望您已经看到了使用 Reason 的一些好处。</p>
<p>如果您发现这个有趣的事情，并希望看到另一篇文章，请点击下面的反应让我知道！ ❤️🦄🔖</p>
<h2>扩展阅读</h2>
<ul>
<li><a href="https://jacklewin.com/2018/getting-started-with-reason">更多的上下文</a>，包括源代码的链接。</li>
<li><a href="http://reasonmlhub.com/exploring-reasonml">探索ReasonML和函数式编程</a> - 一本关于（你猜对了）的免费在线书籍 Reason 和 FP。</li>
</ul>
<h2>OSS项目</h2>
<ul>
<li><a href="https://github.com/glennsl/bs-jest">bs-jest</a> - Jest 的 BuckleScript 绑定。</li>
<li><a href="https://github.com/kennetpostigo/lwt-node">lwt-node</a> - Node.js API的 Reason 实现</li>
<li><a href="https://github.com/apollographql/reason-apollo">reason-apollo</a>绑定 Apollo 客户端和 React Apollo</li>
</ul>
<h2>其他</h2>
<ul>
<li><a href="https://discord.gg/reasonml">Discord 频道</a></li>
<li><a href="https://reasonml.chat/">论坛</a></li>
<li><a href="https://reason.town/">Reason Town</a> - ReasonML 语言和社区的播客</li>
<li><a href="https://redex.github.io/">Redex</a> - Reason 包的索引</li>
</ul>

            </div>
        </div>
        </div>
        </div>
    </body>

</html>
