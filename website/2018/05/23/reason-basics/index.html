<!--
 * @Author: Leland
 * @Date: 2019-12-27 15:59:00
 * @Description: Description
 -->
<!doctype html>
<html>

    <head>
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui" />
        <title>Reason 基础知识</title>
        <link href="/css/style.css" rel="stylesheet" />
        <meta name="description" content="Reason 基础知识">
    </head>

    <body>
        <div>
        <div>
        <header class="header">
            <div class="container header-wrap">
                <h1 class="site-name">
                    <a href="/">
                        首页
                    </a>
                </h1>
                <ul class="nav">
                    {{navs}}
                </ul>
            </div>
        </header>
        </div>
        <div class="container main">
        <div class="page-body">
            <div class="markdown-body">
                <h1>Reason 基础知识</h1>
<p>译自： https://github.com/parkerziegler/reason-basics</p>
<blockquote>
<p>人们学习 Reason 编程语言的存储库。</p>
</blockquote>
<h2>目的</h2>
<p>此存储库是 Reason 社区的新手通过简单示例了解该语言的基础知识的地方。你在这里看到的大部分内容都是从<a href="https://reasonml.github.io/docs/en/overview.html">文档</a>中压缩或修改的。文档是一个很好的资源，并为语言背后的设计决策提供了高层次的解释。但是，对于初次使用程序员和首次使用 Reason 的用户来说，他们会感到有点压倒性。这个存储库希望能够简化一些语言，并提供非常清晰，简洁的例子来帮助你了解和使用 Reason。如果您发现任何令人困惑，过于复杂或错误的事情，请<a href="https://github.com/parkerziegler/reason-basics/issues">提交问题</a>或<a href="https://github.com/parkerziegler/reason-basics/pulls">创建拉取请求</a>。</p>
<h2>安装</h2>
<p>遵循相同的标准步骤克隆和本地安装此存储库：</p>
<pre><code class="language-ocaml">git clone https://github.com/parkerziegler/reason-basics.git
cd reason-basics
yarn install
</code></pre>
<h2>运行代码</h2>
<p>该存储库的源文件当前位于 src/index.re 中。要将 Reason 代码编译为 BuckleScript，然后编译为 JS：</p>
<pre><code class="language-ocaml">yarn run build
</code></pre>
<p>编译该文件并在保存时监视更改：</p>
<pre><code class="language-ocaml">yarn run start
</code></pre>
<p>运行代码并查看终端中的输出：</p>
<pre><code class="language-ocaml">node src/index.bs.js
</code></pre>
<p>这期望您的计算机上安装了Node @ 6或更高版本。</p>
<h2>编辑器</h2>
<p>如果使用 vscode，则可以使用 <code>Cmd + Shift + B</code>（在 macOS 上）或 <code>Windows + Shift + B</code>（在 Windows 上）自动构建。</p>
<h2>扩展</h2>
<p>如果您使用 vscode，我建议安装 <a href="https://marketplace.visualstudio.com/items?itemName=freebroccolo.reasonml">OCaml 和 Reason IDE</a> 以获得令人敬畏的 Reason 编码体验。</p>
<h2>让我们学习 Reason</h2>
<blockquote>
<p>注意：这些内容与index.re中的内容相同，只是为了您的欣赏而写在 Markdown 中。</p>
</blockquote>
<p>请注意，此存储库使用 Reason 的 v3 语法。</p>
<pre><code class="language-ocaml">/* 这里是 Reason 中的注释. */
</code></pre>
<p>要在控制台打印，我们可以使用 BuckleScript 的 JS 模块。</p>
<pre><code class="language-ocaml">Js.log(&quot;Hello, BuckleScript and Reason! Luv BuckleScript&quot;);
</code></pre>
<p>我们也可以使用 Reason 的原生 print_* 模块。</p>
<pre><code class="language-ocaml">print_endline(&quot;Hello, BuckleScript and Reason! Luv Reason&quot;);
</code></pre>
<p>请注意，print_endline 只能打印字符串。要打印数据结构，请使用 Js.log 。未来在语言上对此的支持即将到来。</p>
<p>要打印其他类型，您可以使用 Reason 的类型强制方法或 print_* 模块。</p>
<pre><code class="language-ocaml">print_endline(string_of_int(1));
print_endline(string_of_bool(true));
</code></pre>
<p>如果使用 print_* 方法，则需要使用 print_newline() 来获取新行。 print_endline() 为你添加新行。</p>
<pre><code class="language-ocaml">print_int(1);
print_newline();
print_float(1.0);
print_newline();
</code></pre>
<h3>变量</h3>
<p>Reason 中的变量使用 let 定义。 没有 JS 中 const 的概念。</p>
<pre><code class="language-ocaml">let myVar = &quot;myVar&quot;;
let myInt = 1;
</code></pre>
<h3>字符和字符串</h3>
<p>Reason 区分字符( 用单引号 )和字符串( 用双引号 )。</p>
<pre><code class="language-ocaml">let x = 'x';
let y = 'y';
</code></pre>
<p>模式匹配字符的示例。</p>
<pre><code class="language-ocaml">let isXY = char: bool =&gt;
  switch (char) {
    | 'x'
    | 'y'=&gt; true
    | _ =&gt; false
  };
</code></pre>
<p>要将字符转换为字符串，请使用 String.make，将 1 作为第一个参数传递。</p>
<pre><code class="language-ocaml">let stringFromChar: string = String.make(1, x) ++ String.make(1, y);
print_endline(stringFromChar);
</code></pre>
<p>字符串使用 ++ 运算符连接。</p>
<pre><code class="language-ocaml">let greeting = &quot;Hello&quot;;
let space = &quot; &quot;;
let name = &quot;P-Doo&quot;;
let exclamation = &quot;!&quot;;

print_endline(greeting ++ space ++ name ++ exclamation);
</code></pre>
<p>我们可以使用标准库中的 String 方法（ Reason 的内置方法）对字符串进行操作。</p>
<pre><code class="language-ocaml">let whitespaceString = &quot;  _trim me_  &quot;;
let trimmedString = String.trim(whitespaceString);

print_endline(trimedString);

let atString =
  String.map(
    c =&gt;
      switch (c) {
        |' ' =&gt; '@'
        | _ =&gt; c
      },
      whitespaceString
    );
print_endline(atString);
</code></pre>
<p>字符串中的特殊字符需要使用 <code>\</code> 转义。</p>
<pre><code class="language-ocaml">let slash = &quot;\\&quot;;
print_endline(slash);
</code></pre>
<p>原因还支持多行字符串，类似于 JS 模板文字。他们使用 <code>{|</code> 和 <code>|}</code> 分隔。</p>
<pre><code class="language-ocaml">let multilineString = {|Hello
Reasonable
Folks!|};

print_endline(multilineString);
</code></pre>
<p>字符串方法在多行字符串上工作相同。例如，要将多行字符串转换为单行字符串：</p>
<pre><code class="language-ocaml">let singlelineString =
  String.map(
    c =&gt;
      swith (c) {
        | '\n' =&gt; ' '
        | _ =&gt; c
      },
      multilineString
    );

print_endline(singlelineString);
</code></pre>
<p>要在多行字符串中插入变量，请用 <code>j| 和 </code>|j` 包围字符串。</p>
<pre><code class="language-ocaml">let style = &quot;background-color: papayawhip&quot;;
let cssStyle = {j|$style|j};

print_endline(cssStyle);
</code></pre>
<p>要在 Reason 中的字符串中使用 unicode 字符，请使用 <code>js| |js</code> （译者注：或者 <code>j| |j</code>）。</p>
<pre><code class="language-ocaml">let unicodeString = {js|••∆∆••|js};

print_endline(unicodeString);
</code></pre>
<p>获取字符串长度和截取字符串：</p>
<pre><code class="language-ocaml">let background = &quot;background-color: aquamarine&quot;;
let strLength: int = String.length(background);

print_endline(string_of_int(strLength));

let subStr: string =
  String.sub(background, 0, String.index(background, '-'));

print_endline(subStr);
</code></pre>
<h3>条件语句</h3>
<p>条件语句的工作原理与 JS 类似。然而，如果没有 <code>else</code> 的 <code>if</code> 语句，则将其计算为 <code>else{()}</code>，即 <code>unit</code> 类型。</p>
<pre><code class="language-ocaml">let displayGreeting = true;

if (displayGreeting) {
  let message = &quot;Enjoying my ridiculous commentary yet?&quot;;
  print_endline(message);
}
</code></pre>
<p>条件是对其正文内容进行评估的——不需要返回语句。</p>
<pre><code class="language-ocaml">let good = true;
let content =
  if (good){&quot;This tweet is good.&quot;} else {
    &quot;This tweet is bad. please make it better.&quot;
  };

print_endline(content);
</code></pre>
<p>在上面的块中，必须有一个 <code>else</code> 分支对字符串进行评估。如果没有，内容将被分配到 <code>unit</code> 类型，尽管它的目的是作为一个字符串。这会产生编译器错误。还有对三元运算符的支持。</p>
<pre><code class="language-ocaml">let retweet = good ? &quot;Most certainly.&quot; : &quot;Eh, don't think so.&quot;;
print_endline(retweet);
</code></pre>
<h3>作用域</h3>
<p>变量默认为块作用域。让绑定可以使用 <code>{}</code> 创建匿名作用域。</p>
<pre><code class="language-ocaml">let anonymousScope = {
  let name = &quot;Parker&quot;;
  let company = &quot;Formidable&quot;;
  let place = &quot;Seattle&quot;;
  print_endline({j|$name works at $company in $place.|j});
}
</code></pre>
<p><code>nam</code> ， <code>company</code> 和 <code>place</code> 在这里是无法访问的，因为它们是由上面创建的匿名范围持有的。试图在范围之外访问它们会导致错误！</p>
<h3>类型！</h3>
<p>Reason 由 OCaml 顶尖的系统支持。我们可以明确地输入变量，虽然这不是必需的。Reason 往往会为我们推断类型。</p>
<pre><code class="language-ocaml">let petalLength: int = 5;
</code></pre>
<p>我们也可以使用别名类型。</p>
<pre><code class="language-ocaml">type sepalLength = int;
</code></pre>
<p>然后使用它们！</p>
<pre><code class="language-ocaml">let sepalLength: sepalLength = 20;
</code></pre>
<p>我们通过注解参数来输入函数返回值。</p>
<pre><code class="language-ocaml">let flowerLength = (petal: int, sepal: sepalLength): int =&gt; petal + sepal;
print_endline(string_of_in(flowerLength(petalLength, sepalLength)));
</code></pre>
<h3>布尔</h3>
<p>Reason 中的布尔比较类似于 JS 。 <code>===</code> 表示引用相等，而 <code>==</code> 表示结构相等。小心使用 <code>==</code>，Reason 会提醒你这个！</p>
<pre><code class="language-ocaml">let myTuple = (&quot;Parkie&quot;, &quot;is&quot;, 1);
let compareBool = tuple: bool =&gt; tuple === myTuple;

print_endline(string_of_bool(compareBool(myTuple)));
</code></pre>
<p>这条线会产生多态比较（可能不安全）。</p>
<pre><code class="language-ocaml">print_endline(string_of_bool(('M', 23) == ('M', 23)));
</code></pre>
<p>该行不会产生警告。</p>
<pre><code class="language-ocaml">print_endline(string_of_bool(('M', 23) === ('M', 23)));
</code></pre>
<h3>整数和浮点数</h3>
<p>Reason 有整数和浮点数的概念，而不仅仅是 JS 数字。</p>
<pre><code class="language-ocaml">let githubStars: int = 9;
let squareInt = (num: int): int =&gt; num * num;

print_endline(string_of_int(squareInt(githubStars)));
</code></pre>
<p>要使用整数，请使用 Reason's Pervasives 模块中的方法。这些已经在范围内。</p>
<pre><code class="language-ocaml">let start: int = 1;
+ start; /* 一元添加 */
- start; /* 一元相减 */
let remainder = 20 mod 5;

print_endline(string_of_int(remainder));
</code></pre>
<p>浮点数具有唯一的操作数语法，附加 . 到 <code>+, -, *, /</code> 操作符上。</p>
<pre><code class="language-ocaml">let pi: float = 3.1415926;
let circleArea = (radius: float): float =&gt; pi *. radius *. radius;

print_endline(string_of_float(circleArea(20.0)));

let radius = sqrt(circleArea(20.0)) /. pi;

print_endline(string_of_float(radius));

</code></pre>
<h3>元组</h3>
<p>元组在创建时是不可变的、有序的、有限的，并且是异构类型的(尽管它们可以是相同类型的)。Tuple 类型只是模仿它们所代表的元组的形状!</p>
<pre><code class="language-ocaml">let myTuple: (char, string, int, string) = ('A', &quot;wonderful&quot;, 100, &quot;tuple&quot;);
</code></pre>
<p>有一些特殊的方法可以获得长度为 2 的元组的元素元素。这些元素可以在 Pervasives 模块中使用。</p>
<pre><code class="language-ocaml">let twoTuple: (string, string) = (&quot;It&quot;, &quot;Me&quot;);
let first: string = fst(twoTuple);
let second: string = snd(twoTuple);

print_endline(first);
print_endline(second);
</code></pre>
<p>大多数元组元素都是使用解构来访问的。</p>
<pre><code class="language-ocaml">let (_, _, third: int, _) = myTuple;
print_endline(string_of_int(third));
</code></pre>
<p>元组对于模式匹配多个参数特别有用。</p>
<pre><code class="language-ocaml">let rotate = (x, y) =&gt;
  switch (x, y) {
    | (180, (-180)) =&gt; print_endline({j|Rotate $x, $y|j})
    | (90, (-90)) =&gt; print_endline({j|Turn $x, $y|j})
    | (_, _) =&gt; print_endline(&quot;Hold steady!&quot;)
  };

rotate(180, -180);
rotate(90, -90);
rotate(50, 70);
</code></pre>
<h3>记录</h3>
<p>记录类似于 JS 对象，但更轻，默认情况下不可变，固定在字段名称和类型中，速度更快，键入更严格。记录类型是必需的 - 如果不写类型，编译器会报错！请务必使用 mutable 关键字预先设置可变属性。</p>
<pre><code class="language-ocaml">type team = {
  name: string,
  mutable rank: int,
  average: float,
};

let redSox: team = {
  name: &quot;Red Sox&quot;,
  rank: 1,
  average: 0.326
};

</code></pre>
<p>记录的 <code>keys</code> 通过点符号访问。</p>
<pre><code class="language-ocaml">print_endline(redSox.name);
print_endline(string_of_float(redSox.average));
</code></pre>
<p>使用扩展操作符可以从旧记录中创建新的记录。但是，扩展不能添加新字段，因为记录受到类型限制。</p>
<pre><code class="language-ocaml">let redSoxUpdate = {...redSox, average: 0.418};
print_endline(string_of_float(redSoxUpdate.average));
</code></pre>
<p>现有的记录可以使用 <code>=</code> 更新可变字段。</p>
<pre><code class="language-ocaml">redSox.rank = redSox.rank + 1;
print_endline(string_of_int(redSox.rank));
</code></pre>
<p>在 Reason 中记录也有双关语，类似于ES6对象简写语法。如果值和键匹配，这允许您只提供关键名称。</p>
<pre><code class="language-ocaml">let capital = &quot;Olympia&quot;;
let population = 6000000;

type state = {
  capital: string,
  population: int,
};

let washington: state = {
  capital,
  population
};
</code></pre>
<p>你也可以用类型双关！</p>
<pre><code class="language-ocaml">type place = {
  state,
  team,
};

let seattle: place = {
  state: washington,
  team: {
    name: &quot;Mariners&quot;,
    rank: 3,
    average: 0.298,
  },
};
</code></pre>
<p>尽管记录与 JS 对象有些类似，但您必须更加认识它们的类型。将数据记录用于不改变形状的数据。记录被编译为具有数组索引访问权限的 JS 数组，使其快速。更改记录的类型还可以帮助标记需要更新数据结构的位置，从而使调试变得更加简单！</p>
<p>如果你对使用 JS 本地对象感兴趣，Reason 提供了一个简写语法。这涉及用双引号（<code>&quot;&quot;</code>）来包装 <code>key</code> 名称。</p>
<pre><code class="language-ocaml">type jsObject = {.
  &quot;response&quot;: {.
    &quot;data&quot;: {.
      &quot;starCount&quot;: int,
      &quot;watchers&quot;: int
    },
    &quot;code&quot;: int
  }
};

let jsObject:jsObject = {
  &quot;response&quot;: {
    &quot;data&quot;: {
      &quot;starCount&quot;: 9,
      &quot;watchers&quot;: 2
    },
    &quot;code&quot;: 200
  }
};
</code></pre>
<p>要访问字段，请使用 <code>##</code> 符号。</p>
<pre><code class="language-ocaml">let starCount: int = jsObject##reponse##data##starCount;
print_endline(string_of_int(starCount));
</code></pre>
<h3>变种</h3>
<p>变体是 Reason 中唯一的数据结构。他们让我们表达这种或那种关系。</p>
<pre><code class="language-ocaml">type tweetQuality =
  | Dope /* 这些被称为变体的构造函数或标签。 */
  | Sweet
  | NotBad
  | AF
</code></pre>
<p>变体通常与 Reason 的 switch 语句一起用于模式匹配。</p>
<pre><code class="language-ocaml">let tweetStatus = status: string =&gt;
  switch (status) {
    | Dope =&gt; &quot;That was a dope tweet!&quot;
    | Sweet =&gt; &quot;Pretty sweet tweet!&quot;
    | NotBad =&gt; &quot;Not great, but not bad!&quot;
    | AF =&gt; &quot;Pretty af tweet my friend!&quot;
  };

print_endline(tweetStatus(AF));
</code></pre>
<p>变体需要明确的定义。通过调用它们所在的模块来导入它们。</p>
<pre><code class="language-ocaml">let team: Team.seattleVariant = Mariners;
</code></pre>
<p>变体构造函数也可以带参数。查看 Team.re 中的 seattleVariant，它具有以下形状：</p>
<pre><code class="language-ocaml">type seattleVariant =
  | Mariners(player)
  | Sonics(player, year)
  | Seahawks
  | Sounders;
</code></pre>
<p>这看起来很像函数参数！我们可以在模式匹配中使用这个优势！</p>
<pre><code class="language-ocaml">open Team;
let player: Team.bostonVariant = RedSox(&quot;Mookie Betts&quot;);

let namePlayer = arg =&gt;
  switch (arg) {
    | RedSox(name) =&gt; {j|You chose $name|j}
    | Celtics(name, year) =&gt; year &lt; 2008 ? name : &quot;Big 3&quot;
    | Patriots =&gt; &quot;Malcolm Butler&quot;
    | Bruins =&gt; &quot;Zdeno Chara&quot;
  };

print_endline(namePlayer(player));
print_endline(namePlayer(Celtics(&quot;Larry Bird&quot;, 2009)));
print_endline(namePlayer(Celtics(&quot;Larry Bird&quot;,1984)))
</code></pre>
<p>独立库为您提供了一些很酷的变体。<code>type option('a) = None | Some('a)</code>;- 这允许你定义可以为 <code>null</code> 或者 <code>undefined</code> 的类型。例如，<code>option(int)</code> 键入一个变量作为可为空的整数。</p>
<pre><code class="language-ocaml">let isNull = true;

let possiblyNullInt: option(int) =
  if (isNull) {
    None
  } else {
    Some(5);
  };

let checkNull = (num: option(int)) =&gt; {
  switch (num) {
    | Some(int) =&gt; false
    | None =&gt; true
  };

print_endline(string_of_bool(checkNull(possiblyNullInt)));
}
</code></pre>
<h3>列表和数组</h3>
<p>列表是同类型的，不可变的，并且在预添加项目时很快。列表看起来很像 JS 中的数组。</p>
<pre><code class="language-ocaml">let fibList: list(int) = [1, 1, 2, 3, 5, 8, 13, 21];
</code></pre>
<p>要添加到列表中，请使用延展运算符。这不会改变原始列表。相反，新列表维护一个链接到扩展列表。例如，下面的 fibListHeadZero 与 fibList 共享其元素，使其非常高效。</p>
<pre><code class="language-ocaml">let fibListHeadZero = [0, ...fibList];
</code></pre>
<p>需要注意的是，在 Reason 中不允许使用双延展操作符，即不允许类似这样 [a,...b,...c] 。要访问任意列表项，请使用 List 模块中的 List.nth。</p>
<pre><code class="language-ocaml">let five = List.nth(fibList, 4);
print_endline(string_of_int(five));
</code></pre>
<p>要获得列表的长度，使用List.length。</p>
<pre><code class="language-ocaml">let length: int = List.length(fibList);
let lastItem: int = List.nth(fibList, length - 1);
</code></pre>
<p>List 模块 附带有用于在列表上操作的附加内置方法。</p>
<pre><code class="language-ocaml">let reverse = List.rev(fibList);
let sum = List.fold_left((acc, el) =&gt; acc + el, 0, fibList);
print_endline(string_of_int(sum));

let thriteen = List.find(item =&gt; item === 13, fibList);
print_endline(string_of_int(thirteen));
let aboveTen = List.filter(item =&gt; item &gt; 10, fibList);

List.iter(item =&gt; print_endline(string_of_int(item)), aboveTen);
</code></pre>
<p>数组就像列表，但是对于随机访问和更新是可变的和优化的。它们的大小是固定的，但在 JS 上是灵活的。数组的两端都用 <code>[|</code> 和 <code>|]</code> 表示。</p>
<pre><code class="language-ocaml">let fibArray: array(int) = [|1, 1, 2, 3, 5, 8, 13, 21|];
</code></pre>
<p>数组访问和更新类似于 JS。</p>
<pre><code class="language-ocaml">let length: int = Array.length(fibArray);
let lastItem: int = fibArray[length - 1]
fibArray[2] = 500;
</code></pre>
<p>您也可以使用标准库中的 <code>Array.get</code> 和 <code>Array.set</code>。</p>
<pre><code class="language-ocaml">fibArray[2] = 1000;
print_endline(string_of_int(fibArray[2]));
</code></pre>
<p>要将数组转换为列表，请在 ArrayLabels 模块中使用 <code>.to_list</code> 函数。</p>
<pre><code class="language-ocaml">let fibArrayAsList: list(int) = ArrayLabels.to_list(fibArray);
let fibListAsArray: Array(int) = ArrayLabels.of_list(fibArrayAsList);
</code></pre>
<p>Reason 还支持多维数组。前两个参数指定数组的维数，而第三个参数提供填充数组的初始值。</p>
<pre><code class="language-ocaml">let multiDemArray = Array.make_matrix(2, 2, &quot;Initial.&quot;);
Js.log(multiDemArray);
</code></pre>
<h3>函数</h3>
<p>函数使用 =&gt; 声明。单行函数是允许的。多行函数应该被 <code>{}</code> 包围。在理由中，所有函数都有参数。如果没有显式参数传递，我们传递 <code>()</code>，unit 类型。</p>
<pre><code class="language-ocaml">let noArg = () : unit =&gt; print_endline(&quot;This is unit!&quot;);
let add = x =&gt; x + x;
let square = x =&gt; x * x;
</code></pre>
<p>管道操作符的预览！</p>
<pre><code class="language-ocaml">let addAndSquare = x =&gt; x |&gt; add |&gt; square;

print_endline(string_of_int(addAndSquare(4)));
</code></pre>
<p>Reason 也有标签参数的概念。由于 Reason 支持 currying（柯里化），因此我们可以使用带标签的参数以任意顺序指定参数。</p>
<pre><code class="language-ocaml">let concatStringInt = (~int: int, ~str: string) =&gt;
  string_of_int(int) ++ &quot; &quot; ++ str;

print_endline(concatStringInt(~str=&quot;is an int.&quot;, ~int=50));
</code></pre>
<p>您也可以使用标签参数来在函数中使用。</p>
<pre><code class="language-ocaml">let calcTriangleArea = (~base as b: float, ~height as h: float): float =&gt; 0.5 *. b *. h;
print_endline(string_of_float(calcTriangleArea(~base=2.0, ~height=7.0)));
</code></pre>
<h3>柯里</h3>
<p>Reason 函数可以自动部分调用。事实上，Reason 中的所有函数都接受一个参数！</p>
<pre><code class="language-ocaml">let multiply = (x, y) =&gt; x * y;
let multiplyByFive = multiply(5);
let result = multiplyByFive(6);

print_endline(string_of_int(result));
</code></pre>
<p>上面的乘法函数相当于</p>
<pre><code class="language-ocaml">let multiply = (x, y) =&gt; x * y;
</code></pre>
<p>OCaml 为我们优化了这一点，以避免不必要的函数分配。</p>
<h3>可选的标签参数</h3>
<p>在 Reason 中可以用 <code>=?</code> 创建可选的标签参数。</p>
<pre><code class="language-ocaml">let sayHello = (~greeting as g, ~name=?, ()) =&gt; {
  let person =
    switch (name) {
      | None =&gt; &quot;&quot;
      | Some(a) =&gt; a
    };
  print_endline(g ++ &quot; &quot; ++ person);
};

sayHello(~greeting=&quot;Marhaba&quot;, ());
sayHello(~greeting=&quot;Ahlan ya&quot;, ~name=&quot;Parker&quot;, ());
</code></pre>
<p>在函数定义的第三个索引中注意到括号 ()，并在上面调用。没有它，Reason 就无法解析函数。<code>greeting</code> 和 <code>name</code> 都可以柯里化和无序运用，所以目前还不清楚 sayHello(~greeting =&quot;Aloha&quot;) 是什么意思。OCaml 解析 () 表示可选标记的 arg 被省略了。否则，它会将该函数解析为正在等待要应用的名称的curried函数。</p>
<pre><code class="language-ocaml">/* 这里我们调用上面定义的实际函数sayHello。 */
let actualFunction = sayHello(~greeting=&quot;Marhaba&quot;, ());

/* 这里我们返回一个可以接受〜name参数的函数。 */
let curriedFunction = sayHello(~greeting=&quot;Marhaba&quot;);

curriedFunction(~name=&quot;Parker&quot;, ());

</code></pre>
<p>有时，您不知道您转发给函数的值是 None 还是 Some(val)。在这种情况下，您可以提供一个明确传递的可选类型。</p>
<pre><code class="language-ocaml">let possibleName: option(string) = Some(&quot;Formidable&quot;);

sayHello(~greeting=&quot;Hi ya&quot;, ~name=?possibleName, ());
</code></pre>
<p>如果 possibleName 具有构造函数 None，那么上面的函数仍然可以工作！</p>
<p>您还可以提供默认值，如 JS。只需在参数定义中使用 <code>=</code> 来指定它们即可。下面，除非通过明确的值，否则 Aloha 将成为问候语的值。</p>
<pre><code class="language-ocaml">let sayHello = (~greeting=&quot;Aloha&quot;, ~name=?, ()) =&gt; {
  let person =
    switch (name) {
      | None =&gt; &quot;&quot;
      | Some(a) =&gt; a
    };
  print_endline(greeting ++ &quot; &quot; ++ person);
};

sayHello();
</code></pre>
<h3>递归函数</h3>
<p>要定义递归函数，请使用 <code>rec</code> 关键字。</p>
<pre><code class="language-ocaml">let rec factorial = (num: int) =&gt;
  if (num === 0) {
    1;
  } else {
    num * factorial(num - 1);
  };

print_endline(string_of_int(factorial(5)));
</code></pre>
<h3>相互递归函数</h3>
<p>函数可以在 Reason 中递归调用对方。使用 <code>and</code> 关键字来实现这一点。下面的示例还预览了我们如何在 Reason 中使用异常来创建自定义错误。</p>
<pre><code class="language-ocaml">exception FactorialArgument(string);

let rec factorialEven = (num: int) =&gt;
  if (num === 0) {
    1;
  } else {
    switch (num mod 2) {
      /* 模式匹配来检查数字是偶数还是奇数。 */
      | 0 =&gt; num * factorialOdd(num - 1)
      | 1 =&gt;
        raise(
          FactorialArgument(
            &quot;factorialEven only accepts even-numbered arguments.&quot;
            )
          )
      | _ =&gt; 1
    };
  }
and factorialOdd = (num: int) =&gt;
  if (num === 0) {
    1;
  } else {
    switch (num mod 2) {
      | 0 =&gt;
        raise(
          FactorialArgument(
            &quot;factorialOdd only accepts odd-numbered arguments.&quot;
            )
          )
      | 1 =&gt; num * factorialEven(num - 1)
      | _ =&gt; 1
    };
  };

print_endline(string_of_int(factorialEven(6)));
print_endline(string_of_int(factorialOdd(5)));

</code></pre>
<p>以下调用会抛出我们的 FactorialArgument 异常，并说 factorialEven 只接受偶数参数。</p>
<pre><code class="language-ocaml">print_endline(string_of_int(factorialEven(5)));
</code></pre>
<p>如果您来自 JS，上述模式的用处就会起作用，因为 Reason / OCaml 不会提升变量或函数声明！考虑如何调用两个函数 a 和 b 来调用另一个函数。这在 JS 中是可行的，因为函数声明被提升到作用域的顶部。既然 Reason 没有提升，相互递归就是解决这个问题的一种技术。</p>
<h3>更多关于类型</h3>
<p>您可以在 Reason 中创建参数化类型，以使类型更具表现力。它们像函数一样，接受参数和返回类型。类型参数前缀为 <code>'</code>。</p>
<pre><code class="language-ocaml">type measurements('a) = ('a, 'a)
type measurementsInt = measurements(int);
type measurementsString = measurements(string);

let modalSize: measurements(int) = (150, 300);
let modalArea = fst(modalSize) * snd(modalSize);

print_endline(string_of_int(modalArea));

let dialogSize: measurements(string) = (&quot;500&quot;, &quot;1000&quot;);
let (w, h) = dialogSize;
let dialogDescription = {j| This dialog is $w by $h px |j};

print_endline(dialogDescription);

</code></pre>
<p>大多数情况下，Reason 的类型推断将会为您处理参数类型!</p>
<p>类型也可以使用变体。</p>
<pre><code class="language-ocaml">type httpResult('a, 'b) =
  | Success('a)
  | Failure('b);

type payload = {
  data: string,
  code: int,
}
</code></pre>
<p>组合类型 <code>httpResult</code> 需要两个参数，并将它们应用于 <code>Success</code> 和 <code>Failure</code> 构造函数。</p>
<pre><code class="language-ocaml">let result: httpResult(payload, int) = Success({
    data: &quot;woohoo&quot;,
    code: 200
  });

let errResult: httpResult(payload, int) = Failure(404);
</code></pre>
<p>由于 Reason 的类型系统允许使用类型级别的函数，因此不需要太多类型的样板。例如，我们可以使用 <code>list(int)</code> 和 <code>list(string)</code>，而不需要为每个都创建一个新的基本类型，即 listOfInt 和 listOfString。这使得 Reason 的类型系统具有超凡的表现力，同时仍然提供了坚如磐石的系统的脚手架。请享用！</p>
<h3>相互递归类型</h3>
<p>类型如函数，可以是相互递归的。</p>
<pre><code class="language-ocaml">type professor = {courses: list(course)}
and course = {
  name: string,
  professor,
};
</code></pre>
<h3>解构</h3>
<p>解构是 Reason 中的常见模式，对于从结构中提取数据非常有用。</p>
<pre><code class="language-ocaml">let teams = (&quot;Mariners&quot;, &quot;Red Sox&quot;, &quot;Astros&quot;, &quot;Twins&quot;);
let (ms, bosox, stros, twins) = teams;

print_endline(
  {j|$ms, $bosox, $stros, $twins === Parkie-Doo's playoff picks.|j}
  );
</code></pre>
<p>以下是如何解构 Reason 记录。它看起来很像 JS 中的对象解构。</p>
<pre><code class="language-ocaml">type album = {
  name: string,
  artist: string,
  year: int,
};

let myFavoriteAlbum: album = {
  name: &quot;Illinois&quot;,
  artist: &quot;Sufjan Stevens&quot;,
  year: 2004,
};

let {name, artist, year} = myFavoriteAlbum;

print_endline({j|$artist wrote $name in $year.|j});
</code></pre>
<p>当您解构它们的时候也可以给变量起别名，全部在一行中！这与 ES6 解构相似。</p>
<pre><code class="language-ocaml">let {name: n, artist: a, year: y} = myFavoriteAlbum;

print_endline({j|$a wrote $n in $y.|j})
</code></pre>
<p>你甚至可以解构和别名函数参数！</p>
<pre><code class="language-ocaml">type exclamation = {
  phrase: string,
  volume: float,
};

let exclaim = (~exclamation as {phrase} as exclamation) =&gt;
/* 您可以访问惊叹号（记录）和 短语属性作为一个解构变量。 */
print_endline(
  {j|And lo, Parkie-Doo shouted, $phrase at $exclamation.volume DB.|j}
  );

exclaim(~exclamation={phrase: &quot;Breathtaking, this Reason!&quot;, volume: 120.7});
</code></pre>
<h3>模式匹配</h3>
<p>模式匹配是将数据与一组值相匹配的好方法。模式匹配最好与变体一起使用 - 何时这样做，我们可以从类型系统获得很好的全面帮助，从而检查不匹配的案例。</p>
<pre><code class="language-ocaml">type victory =
  | NailBiter(int)
  | BlowOut(int)
  | OT(string, int);

let myVictory: victory = OT(&quot;8:03&quot;, 1);
</code></pre>
<p>模式匹配允许我们解构变体，分别处理每个案例。要查看编​​译器警告你一个不匹配的情况，请尝试在下面注释掉 BlowOut。</p>
<pre><code class="language-ocaml">let myOTVictory =
  switch (myVictory) {
    | NailBiter(margin) =&gt; {j|yeesh, close game. Nice win by $margin.|j}
    | BlowOut(margin) =&gt; {j|Damn, what a blowout. $margin run is impressive|j}
    | OT(time, margin) =&gt; {j|It took $time to win by $margin. But a win's a win.|j}
  };

print_endline(myOTVictory);
</code></pre>
<p>我们也可以用其他数据结构来切换其他情况。例如，一个 <code>array(int)</code>。</p>
<pre><code class="language-ocaml">let arr = [|500, 600|];

let handleArray = (array: array(int)) =&gt;
  switch (array) {
    | [|500, 600|] =&gt; print_endline(&quot;This is a very specific case.&quot;)
    | [|500, _|] =&gt; print_endline(&quot;You have two items in this array, and the first is 500.&quot;)
    | [|_, _|] =&gt; print_endline(&quot;You have two items in this array.&quot;)
    | _ =&gt; print_endline(&quot;This is the default.&quot;)
  };

handleArray(arr);
handleArray([|500, 601|]);
handleArray([|101, 102|]);
handleArray([|1s|]);
</code></pre>
<p>你甚至可以模式匹配一​​组结果到一个特定的结果。例如，让我们将服务器上的错误映射到特定的结果。</p>
<pre><code class="language-ocaml">type httpResultWithCode =
  | Success(int, list(string))
  | Failure(int);

let handleResult = (res: httpResultWithCode) =&gt;
  switch (res) {
    | Success(200, data) =&gt;
      let f = (acc, el) =&gt; acc ++ &quot; &quot; ++ el;
      /* 我们在这里使用 fold_left 来连接字符串。 fold_left 类似于 reduce，但用于列表！ */
      let resString = ListLabels.fold_left(~f, ~init=&quot;&quot;, data);
      print_endline({j|data: $resString|j});
    | Failure(500)
    | Failure(502) =&gt; print_endline(&quot;Server error.&quot;)
    | Failure(404) =&gt; print_endline(&quot;Not found.&quot;)
    | _ =&gt; print_endline(&quot;we don't know what happened, sorry!&quot;)
  };

handleResult(Failure(500));
handleResult(Failure(501));
handleResult(Success(200, [&quot;You&quot;, &quot;Rock&quot;]));
handleResult(Success(201, [&quot;You&quot;, &quot;Are&quot;, &quot;Still&quot;, &quot;Great&quot;]));
</code></pre>
<p>您也可以使用 <code>when</code> 子句来检查案例的特定条件。这就像在你的模式匹配逻辑中添加一点点 <code>if</code> 语法糖。扩展我们上面的例子：</p>
<pre><code class="language-ocaml">let isServerError = err =&gt; err === 500;
let isBadGateway = err =&gt; err === 502;

let handleResult = (res: httpResultWithCode) =&gt;
  switch (res) {
    | Success(200, data) =&gt;
      let f = (acc, el) =&gt; acc ++ &quot; &quot; ++ el;
      let resString = ListLabels.fold_left(~f, ~init=&quot;&quot;, data);
      print_endline({j|data: $resString|j});
    | Failure(errCode) when isServerError(errCode) =&gt;
      print_endline(&quot;Server error.&quot;)
    | Failure(errCode) when isBadGateway(errCode) =&gt;
      print_endline(&quot;Bad gateway. Getaway? Who knows?&quot;)
    | Failure(404) =&gt; print_endline(&quot;Not found.&quot;)
    | _ =&gt; print_endline(&quot;we don't know what happened, sorry!&quot;)
  };

handleResult(Failure(500));
handleResult(Failure(502));
</code></pre>
<p>您也可以嵌套模式，这意味着我们可以对数据结构的嵌套属性进行模式匹配。</p>
<pre><code class="language-ocaml">type composer = {
  name: string,
  concertos: int,
};

let evaluateComposer = (composer: composer) =&gt;
  switch (composer) {
    | {name: &quot;Beethoven&quot; | &quot;Mozart&quot; | &quot;Debussy&quot;} =&gt; &quot;What high class. How fancy!&quot;
    | composer when composer.concertos &lt;= 7 =&gt; &quot;Not too bad, but nothing special.&quot;
    | _ =&gt; &quot;Just another composer&quot;
  };

print_endline(evaluateComposer({name: &quot;Debussy&quot;, concertos: 57}));
print_endline(evaluateComposer({name: &quot;Jerry&quot;, concertos: 7}));
</code></pre>
<h3>变动</h3>
<p><code>let</code> 绑定默认情况下是不可变的。如果你需要改变一个 <code>let</code> 绑定,使用 <code>ref</code> 关键字的包起它的值。</p>
<pre><code class="language-ocaml">let mutableVar = ref(&quot;mutable&quot;);
</code></pre>
<p>要访问它，请使用 <code>^</code> 运算符。</p>
<pre><code class="language-ocaml">let mutableReference = mutableVar^;
</code></pre>
<p>要重新分配一个可变变量，请使用 <code>:=</code> 运算符。</p>
<pre><code class="language-ocaml">mutableVar := &quot;mutated&quot;;
print_endline(mutableVar^);
</code></pre>
<p>然而，你也可以简单地通过用另一个let绑定来映射它们来改变变量。</p>
<pre><code class="language-ocaml">let shodow = &quot;First I am this!&quot;;

print_endline(shadow);

let shadow = &quot;But now I've been shadowed!&quot;;

print_endline(shadow);
</code></pre>
<h3>命令式循环</h3>
<p>for 循环在 Reason 中迭代从一个开始直到包括一个结束值。</p>
<pre><code class="language-ocaml">let repeatCapitalize = (~time: int, ~str: string) =&gt; {
  let result = ref(&quot;&quot;);
  for (time in 1 to times) {
    switch (time mod 2) {
      | 0 =&gt; result := result^ ++ String.capitalize(str)
      | 1 =&gt; result := result^ ++ str
      | _ =&gt; result := result^ ++ str
    };
  };
  result^;
};

print_endline(repeatCapitalize(~time=5, ~str=&quot;reason&quot;));
</code></pre>
<p>您也可以使用 <code>downto</code> 操作符从一个数字开始迭代。</p>
<pre><code class="language-ocaml">let factorialSum = (~num: int): int =&gt; {
  let result = ref(0);
  for (n in num downto 0) {
    result := result^ + n;
  };
  result^;
};

print_endline(string_of_int(factorialSum(~num=5)));
</code></pre>
<p>总的来说，<code>Array</code> 和 <code>List</code> 方法可能会让你更接近你想要的东西，而不是 for 循环，但是它们很好知道。您也可以像在 JS 中那样使用 while 循环。</p>
<pre><code class="language-ocaml">let count = ref(1);

while (count &lt; ref(5)) {
  print_endline(&quot;We are while looping!&quot;);
  count := count^ + 1;
};
</code></pre>
<p>使用上面的可变绑定来跳出循环。Reason 没有像 JS 这样的 <code>break</code> 关键字的概念。</p>
<h3>JSX</h3>
<p>Reason 本身支持 JSX 。调用如下：</p>
<pre><code class="language-ocaml">&lt;div foo={bar}&gt; child1 child2 &lt;/div&gt;
</code></pre>
<p>变成：</p>
<pre><code class="language-ocaml">([@JSX] div(~foo=bar, ~children=[child1, child2], ()));
</code></pre>
<p>[@JSX] 语法将一个函数标记为想要格式化为 JSX。这在任何 Reason 库中都是允许的，而不仅仅是 ReasonReact，来利用JSX。</p>
<h3>外部对象</h3>
<p>外部是理性与其他语言（通常是 JS ）的交互方式。使用外部最常用的方法之一是加载模块。例如，让我们从这个 repo 中的 findS 模块加载 findS 函数。</p>
<pre><code class="language-ocaml">[@bs.module &quot;./findS&quot;] external findS: string =&gt; int = &quot;&quot;;

let twos = findS(&quot;strings&quot;);

print_endline(string_of_int(twos));
</code></pre>
<p>优雅！我们从 Reason 中调用了一个 JS 函数！上面的注释允许我们从 findS 模块中键入函数 findS，并返回一个类型安全引用到该模块。让我们看看我们如何访问一个作用域函数，比如 Math.random。</p>
<pre><code class="language-ocaml">[@bs.val] [@bs.scope &quot;Math&quot;] external random : unit =&gt; float = &quot;random&quot;;
[@bs.val] [@bs.scope &quot;Math&quot;] external floor : float =&gt; int = &quot;floor&quot;;
</code></pre>
<p>在上面的定义中，我们说在 Math 作用域中有一个方法叫做 <code>random</code>。它将 unit 类型作为参数并返回一个浮点数。我们将它别名命名为 <code>random</code> ，以便在 Reason 中使用。现在我们可以使用它！</p>
<pre><code class="language-ocaml">let getRandomInt = (~max as m: float) =&gt;
  floor(random() *. float_of_int(floor(m)));

print_endline(string_of_int(getRandomInt(~max=100.0)));
</code></pre>
<h3>对象</h3>
<p>大多数情况下，您将使用记录来存储名称和值。但有时候，你会想要一个对象。请注意，Reason 中的对象与 JS 对象不同。使用 <code>pub</code> 关键字将对象的公共值前缀。 <code>val</code> 可用于定义不可从外部访问的对象上的值。 <code>pri</code> 可以定义私有方法。</p>
<pre><code class="language-ocaml">let anUntypeReasonObject = {pub city = &quot;Burlington&quot;; val state = &quot;Vermont&quot;};

print_endline(anUntypeReasonObject#city);
</code></pre>
<p>Reason 对象不需要类型定义。如果我们确定它们，则该对象必须具有所提供的类型的形状。</p>
<pre><code class="language-ocaml">type locale = {
  .
  city: string,
  state: string,
  population: int,
};

let burlington: locale = {
  pub city = &quot;Burlington&quot;;
  pub state = &quot;Vermont&quot;;
  pub population = 56000
};

print_endline(string_of_int(burlington#population));
</code></pre>
<p>两个点（称为elision）表示此对象已打开，并且可以具有除原始类型属性之外的属性。开放对象是多态的，需要一个类型参数。</p>
<pre><code class="language-ocaml">type localeOpen('a) = {.. getplace: unit =&gt; string} as 'a;
</code></pre>
<p>Reason 中的对象有一个 <code>this</code> 上下文，它指向对象本身。</p>
<pre><code class="language-ocaml">let vt: localeOpen({. getPlace: unit =&gt; string}) = {
  val address = &quot;100 Church St&quot;;
  val city = &quot;Burlington&quot;;
  val zipCode = &quot;05712&quot;;
  pub getPlace = () =&gt;
    address ++ &quot;, &quot; ++ city ++ &quot; &quot; ++ zipCode ++ &quot;. &quot; ++ this#addOn();
  pri addOn = () =&gt; &quot;Didn't ya know?&quot;
};

print_endline(vt#getPlace());
</code></pre>
<p>大多数情况下，您将使用记录或 JS 对象来实现您在 JS 中使用的内容。Reason 有一个很好的定义 JS 对象的语法。这涉及到将对象键包装在 <code>&quot;&quot;</code> 中并使用 <code>##</code> 进行访问。</p>
<pre><code class="language-ocaml">let reason = {&quot;color&quot;: &quot;orange&quot;, &quot;language&quot;: &quot;reason&quot;, &quot;users&quot;: 5000};
print_endline(reason##language);
</code></pre>
<p>改变 JS 对象涉及让 BuckleScript 知道我们有一个可变的键 - 值对。为此，请使用 <code>@bs.set</code> 注释类型。然后，使用 <code>#=</code> 改变它。</p>
<pre><code class="language-ocaml">type language = {
  .
  [@bs.set] &quot;color&quot;: string,
  &quot;language&quot;: string,
  &quot;users&quot;: int,
};

[@bs.module &quot;./findS&quot;] external myJSObject : language = &quot;&quot;;

print_endline(myJSObject##language);

myJSObject##color#=&quot;orange&quot;;

print_endline(myJSObject##color);
</code></pre>
<h3>模块</h3>
<p>Reason 中的模块可以包含类型定义，<code>let</code> 绑定，嵌套模块，几乎任何东西。使用 module 关键字来创建一个。</p>
<pre><code class="language-ocaml">module Earth = {
  let continents = [|
    &quot;Africa&quot;,
    &quot;Antarctica&quot;,
    &quot;Asia&quot;,
    &quot;Australia&quot;,
    &quot;Europe&quot;,
    &quot;North America&quot;,
    &quot;South America&quot;,
  |];

  let pickContinent = (idx: int) =&gt; continents[idx];
};

let aussie = Earth.pickContinent(3);

print_endline(aussie);
</code></pre>
<p>我们也可以访问嵌套模块！查看 <code>Team</code> 模块，它有一个嵌套的 <code>Boston</code> 模块。</p>
<pre><code class="language-ocaml">print_endline(Team.Boston.team);
</code></pre>
<p>虽然 Reason 有很好的模块推理 - 没有 <code>import</code> 概念！ - 使用 open 关键字明确地打开模块可能很有用。这将模块纳入作用域内。我们可以在本地为一个特定的函数打开一个模块，如下所示：</p>
<pre><code class="language-ocaml">let fact =
  Team.Boston.(
    switch (team) {
      | &quot;Red Sox&quot; =&gt; &quot;The Red Sox are DOPE.&quot;
      | _ =&gt; &quot;Eh, don't really care.&quot;
    }
  );

print_endline(fact);
</code></pre>
<p>全局打开对于在另一个模块中获取所有内容非常有用。但是要小心，如果模块中有共享名称的成员，这可能会引入不必要的命名冲突/阴影。</p>
<pre><code class="language-ocaml">open Team.Boston;
</code></pre>
<p>模块也可以相互扩展，在传统的 OOP 语言中履行继承或混合的角色。</p>
<pre><code class="language-ocaml">module ExtendedBoston = {
  include Team.Boston;
  let basketball = &quot;Celtics&quot;;
};

print_endline(ExtendedBoston.team);

print_endline(ExtendedBoston.basketball);
</code></pre>
<h3>Promises</h3>
<p>Reason 中的 Promises 通过使用 Js.Promise.* 方法的 BuckleScript 处理。注意。<code>.</code> 作为第一个参数传递到 <code>resolve</code> 。这可以让 BuckleScript 知道这是一个非柯里化函数。这是在 BuckleScript 2.2.2 中引入的。如果使用旧版本的 bs-platform ，则可以使用 <code>[@bs] resolve(100)</code> 获得相同的效果。</p>
<pre><code class="language-ocaml">let promise = Js.Promise.make((~resolve, ~reject as _) =&gt; resolve(. 100));

exception Failure(string);
let failedPromise = Js.Promise.make((~resolve as _, ~reject) =&gt; reject(. Failure(&quot;Rejected!&quot;)));

promise
|&gt; Js.Promise.then_(res =&gt; {
    Js.log(res);
    Js.Promise.resolve(res);
})
|&gt; Js.Promise.then_(res =&gt; {
    Js.log(&quot;That's all folks!&quot;);
    Js.Promise.resolve(res - 100);
})
|&gt; Js.Promise.catch(err =&gt; {
    Js.log2(&quot;Failure!!&quot;, err);
    Js.Promise.resolve(-1);
});

failedPromise
|&gt; Js.Promise.then_(res =&gt; {
    Js.log(res)
    Js.Promise.resolve(res);
})
|&gt; Js.Promise.then_(res =&gt; {
    Js.Promise.resolve(res - 100);
})
|&gt; Js.Promise.catch(err =&gt; {
    Js.log2(&quot;Failure!!&quot;, err);
    Js.Promise.resolve(-1);
});
</code></pre>
<h3>异常</h3>
<p>异常是一种特殊的变体，在 Reason 中不常使用。</p>
<p>下面的函数展示了如何使用 <code>raise</code> 关键字使用 <code>Not_found</code>、<code>exception</code>。</p>
<pre><code class="language-ocaml">let aFunkyList = [&quot;Parliament&quot;, &quot;Funkadelic&quot;, &quot;George Clinton&quot;];
  if (List.exists(item =&gt; item ===&quot;Stevie Wonder&quot;, aFunkyList)) {
    print_endline(&quot;Yay Stevie!&quot;);
  } else {
    /* 在这里，我们引发 Exception 变体的 Not_found 构造函数。 */
    raise(Not_found);
  }
</code></pre>

            </div>
        </div>
        </div>
        </div>
    </body>

</html>
