<!--
 * @Author: Leland
 * @Date: 2019-12-27 15:59:00
 * @Description: Description
 -->
<!doctype html>
<html>

    <head>
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui" />
        <title>F# 备忘单</title>
        <link href="/css/style.css" rel="stylesheet" />
        <meta name="description" content="F# 备忘单">
    </head>

    <body>
        <div>
        <div>
        <header class="header">
            <div class="container header-wrap">
                <h1 class="site-name">
                    <a href="/">
                        首页
                    </a>
                </h1>
                <ul class="nav">
                    {{navs}}
                </ul>
            </div>
        </header>
        </div>
        <div class="container main">
        <div class="page-body">
            <div class="markdown-body">
                <h1>F# 备忘单</h1>
<p>译自：https://dungpa.github.io/fsharp-cheatsheet/</p>
<p>这张备忘单浏览了一些 F# 3.0 的常用语法。如果您有任何意见，更正或建议添加内容，请打开问题或发送拉取请求到https://github.com/dungpa/fsharp-cheatsheet。</p>
<h2>注释</h2>
<p>块注释放在 (* 和 *) 之间。行注释从 // 开始并一直持续到行结束。</p>
<pre><code class="language-text">(* 这是块注释 *)

// 这是行注释
</code></pre>
<p>在 /// 允许我们使用 XML 标记生成文档后，XML 文档注释就会出现。</p>
<pre><code class="language-fsharp">/// `let`关键字定义了一个（不可变的）值
let result = 1 + 1 = 2
</code></pre>
<h2>字符串</h2>
<p>F# 字符串类型是 System.String 类型的别名。</p>
<pre><code class="language-fsharp">/// 使用字符串连接创建字符串
let hello = &quot;Hello&quot; + &quot;World&quot;
</code></pre>
<p>使用以 @ 符号开头的逐字字符串以避免转义控制字符（除了通过 &quot;&quot; 转义 &quot;）。</p>
<pre><code class="language-fsharp">let verbatimXml = @&quot;&lt;book title=&quot;&quot; Paradise Lost &quot;&quot;&gt;&quot;
</code></pre>
<p>我们甚至不必转义 &quot; 使用三引号字符串。</p>
<pre><code class="language-fsharp">let tripleXml = &quot;&quot;&quot;&lt;book title=&quot;Paradise Lost&quot;&gt;&quot;&quot;&quot;
</code></pre>
<p>反斜杠字符串通过去除前导空格来缩进字符串内容。</p>
<pre><code class="language-fsharp">let poem = 
    &quot;The lesser world was daubed\n\
     By a colorist of modest skill\n\
     A master limned you in the finest inks\n\
     And with a fresh-cut quill.&quot;
</code></pre>
<h2>基本类型和文字</h2>
<p>大多数数字类型都有相关的后缀，例如，uy 表示无符号 8 位整数，L 表示有符号 64 位整数。</p>
<pre><code class="language-fsharp">let b, i, l = 86uy, 86, 86L

val b : byte = 86uy
val i : int = 86
val l : int64 = 86L
</code></pre>
<p>其他常见的例子是 32 位浮点数的 F 或 f ，小数的 M 或 m ，大整数的 I。</p>
<pre><code class="language-fsharp">let s, f, d, bi = 4.14F, 4.14, 0.7833M, 9999I

val s : float32 = 4.14f
val f : float = 4.14
val d : decimal = 0.7833M
val bi : System.Numerics.BigInteger = 9999
</code></pre>
<p>有关完整参考，请<a href="http://msdn.microsoft.com/en-us/library/dd233193.aspx">参阅文字（MSDN）</a>。</p>
<h2>函数</h2>
<p>let 关键字还定义了命名函数。</p>
<pre><code class="language-fsharp">let negate x = x * -1
let square x = x * x
let print x = printfn &quot;The number is: %d&quot; x

let squareNegateThenPrint x = 
    print (negate (square x))
</code></pre>
<h3>管道和组合操作符</h3>
<p>管道运算符 |&gt; 用于将函数和参数链接在一起。双重反引号标识符便于提高可读性，尤其是在单元测试中：</p>
<pre><code class="language-fsharp">let ``square, negate, then print`` x = 
    x |&gt; square |&gt; negate |&gt; print
</code></pre>
<p>此运算符在使用前通过提供类型信息来协助 F# 类型检查器是必不可少的：</p>
<pre><code class="language-fsharp">let sumOfLengths (xs : string []) =
    xs
    |&gt; Array.map (fun s -&gt; s.Length)
    |&gt; Array.sum
</code></pre>
<p>组合运算符 &gt;&gt; 用于组合函数：</p>
<pre><code class="language-fsharp">let squareNegateThenPrint' = 
    square &gt;&gt; negate &gt;&gt; print
</code></pre>
<h3>递归函数</h3>
<p>rec 关键字与 let 关键字一起用于定义递归函数：</p>
<pre><code class="language-fsharp">let rec fact x = 
    if x &lt; 1 then 1
    else x * fact (x - 1)
</code></pre>
<p>相互递归函数（那些相互调用的函数）由 and 关键字表示：</p>
<pre><code class="language-fsharp">let rec even x = 
    if x = 0 then true
    else odd (x - 1)
end odd x = 
    if x = 1 then true
    else even (x - 1)
</code></pre>
<h2>模式匹配</h2>
<p>通常通过 match 关键字来促进模式匹配。</p>
<pre><code class="language-fsharp">let rec fib n = 
    match n with
    | 0 -&gt; 0
    | 1 -&gt; 1
    | _ -&gt; fib (n - 1) + fib (n - 2)
</code></pre>
<p>为了匹配复杂的输入，可以使用 when 在模式上创建过滤器或防护：</p>
<pre><code class="language-fsharp">let sign x = 
    match x with
    | 0 -&gt; 0
    | x when x &lt; 0 -&gt; -1
    | x -&gt; 1
</code></pre>
<p>模式匹配可以直接在参数上完成：</p>
<pre><code class="language-fsharp">let fst' (x, _) = x
</code></pre>
<p>或通过 function 关键字隐式：</p>
<pre><code class="language-fsharp">/// 类似于 `fib`;使用 `function` 进行模式匹配
let rec fib' = function
    | 0 -&gt; 0
    | 1 -&gt; 1
    | n -&gt; fib' (n - 1) + fib' (n - 2)
</code></pre>
<p>有关更完整的参考，请访问<a href="http://msdn.microsoft.com/en-us/library/dd547125.aspx">模式匹配（MSDN）</a>。</p>
<h2>集合</h2>
<h3>列表</h3>
<p>列表是相同类型的元素的不可变集合。</p>
<pre><code class="language-fsharp">// 列表使用方括号和`;`分隔符
let list1 = [&quot;a&quot;;&quot;b&quot;]
// :: 用于将元素加在列表开头
let list2 = &quot;c&quot; :: list1
// @ 用于连接列表
let list3 = list1 @ list2

// 使用( :: )运算符在列表上递归
let rec sum list = 
    match list with
    | [] -&gt; 0
    | x :: xs -&gt; x + sum xs
</code></pre>
<h3>数组</h3>
<p>数组是连续数据元素的固定大小，从零开始，可变的集合。</p>
<pre><code class="language-fsharp">// 数组使用方括号和条形
let array1 = [|&quot;a&quot;;&quot;c&quot;|]
// 使用点进行索引访问
let first = array1.[0]
</code></pre>
<h3>序列</h3>
<p>序列是相同类型的逻辑系列元素。仅根据需要计算各个序列元素，因此在不使用所有元素的情况下，序列可以提供比列表更好的性能。</p>
<pre><code class="language-fsharp">// 序列可以使用 yield 并包含子序列
let seq1 = 
    seq {
        // “yield”增加一个元素
        yield 1
        yield 2

        // &quot;yield!&quot; 添加一个完整的子序列
        yield! [5..10]
    }

</code></pre>
<h3>集合上的高阶函数</h3>
<p>同样的清单 [1; 3; 5; 7; 9] 或数组 [| 1; 3; 5; 7; 9 |] 可以以各种方式生成。</p>
<ul>
<li>使用范围运算符..</li>
</ul>
<pre><code class="language-fsharp">let xs = [1..2..9]
</code></pre>
<ul>
<li>使用列表或数组理解</li>
</ul>
<pre><code class="language-fsharp">let yx = [| for i in 0..4 -&gt; 2 * i + 1 |]
</code></pre>
<ul>
<li>使用 init 函数</li>
</ul>
<pre><code class="language-fsharp">let zs = List.init 5 (fun i -&gt; 2 * i + 1)
</code></pre>
<p>列表和数组具有用于操作的全面的高阶函数集。</p>
<ul>
<li>fold 从列表（或数组）的左侧开始，foldBack 的方向相反</li>
</ul>
<pre><code class="language-fsharp">let xs' = Array.fold (fun str n -&gt; sprintf &quot;%s,%i&quot; str n) &quot;&quot; [|0..9|]
</code></pre>
<ul>
<li>reduce 不需要初始累加器</li>
</ul>
<pre><code class="language-fsharp">let last xs = List.reduce (fun acc x -&gt; x) xs
</code></pre>
<ul>
<li>map 转换列表（或数组）的每个元素</li>
</ul>
<pre><code class="language-fsharp">let ys' = Array.map (fun x -&gt; x * x) [|0..9|]
</code></pre>
<ul>
<li>iter 列表并产生副作用</li>
</ul>
<pre><code class="language-fsharp">let _ = List.iter (printfn &quot;%i&quot;) [0..9]
</code></pre>
<p>所有这些操作也可用于序列。序列的附加好处是对实现 IEnumerable&lt;'T&gt; 的所有集合的懒惰和统一处理。</p>
<pre><code class="language-fsharp">let zs' = 
    seq {
        for i in 0..9 do
            printfn &quot;Adding %d&quot; i
            yield i
    }
</code></pre>
<h2>元组和记录</h2>
<p>元组是一组未命名但有序的值，可能是不同类型的：</p>
<pre><code class="language-fsharp">// 元组结构
let x = (1, &quot;Hello&quot;)

// 三重
let y = (&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)

// 元组解构/模式
let (a', b') = x
</code></pre>
<p>可以使用 fst，snd 或模式匹配获得元组的第一个和第二个元素：</p>
<pre><code class="language-fsharp">let c' = fst (1, 2)
let d' = snd (1, 2)

let print' tuple = 
    match tuple with
    | (a, b) -&gt; printfn &quot;Pair %A %A&quot; a b
</code></pre>
<p>记录表示命名值的简单聚合，可选择包含成员：</p>
<pre><code class="language-fsharp">// 声明记录类型
type Person = { Name: string; Age: int }

// 通过记录表达式创建值
let paul = { Name = &quot;Paul&quot;; Age = 28}

// '复制并更新'记录表达式
let paulsTwin = {paul with Name = &quot;Jim&quot;}

</code></pre>
<p>记录可以使用属性和方法进行扩充：</p>
<pre><code class="language-fsharp">type Person with
    member x.Info = (x.Name, x.Age)
</code></pre>
<p>记录本质上是带有额外顶部的密封类：默认不变性，结构相等和模式匹配支持。</p>
<pre><code class="language-fsharp">let isPaul person = 
    match person with
    | { Name = &quot;Paul&quot; } -&gt; true
    | _ -&gt; false
</code></pre>
<h2>识别联合</h2>
<p>识别联合（DU）为可以是多个命名案例之一的值提供支持，每个案例可能具有不同的值和类型。</p>
<pre><code class="language-fsharp">type Tree&lt;'T&gt; =
    | Node of Tree&lt;'T&gt; * 'T * Tree&lt;'T&gt;
    | Leaf

let rec depth = function 
    | Node(l, _, r) -&gt; 1 + max (depth l) (depth r)
    | Leaf -&gt; 0
</code></pre>
<p>F# Core 有一些用于错误处理的内置区分联合，例如 <a href="http://msdn.microsoft.com/en-us/library/dd233245.aspx">Option</a> 和 <a href="http://msdn.microsoft.com/en-us/library/ee353439.aspx">Choice</a> 。</p>
<pre><code class="language-fsharp">let optionPatternMatch input = 
    match input with
    | Some i -&gt; printfn &quot;input is an int=%d&quot; i
    | None -&gt; printfn &quot;input is missing&quot;
</code></pre>
<p>单例区分联合通常用于创建具有模式匹配支持的类型安全抽象：</p>
<pre><code class="language-fsharp">type OrderId = Order of string

// 创建DU值
let orderId = Order &quot;12&quot;

// 使用模式匹配来解构单个案例 DU
let (Order id) = orderId
</code></pre>
<h2>异常</h2>
<p>failwith 函数抛出异常类型 Exception 。</p>
<pre><code class="language-fsharp">let divideFailwith x y = 
    if y = 0 then
        failwith &quot;Divisor cannot be zero&quot;
    else x / y
</code></pre>
<p>异常处理通过 try / with 表达式完成。</p>
<pre><code class="language-fsharp">let divide x y =
    try
        Some (x / y)
    with :? System.DivideByZeroException -&gt;
        printfn &quot;Division by zero!&quot;
        None
</code></pre>
<p>try / finally 表达式使您可以执行清理代码，即使代码块引发异常也是如此。这是一个定义自定义异常的示例。</p>
<pre><code class="language-fsharp">exception InnerError of string
exception OuterError of string

let handleErrors x y =
    try
        try
            if x = y then raise (InnerError(&quot;inner&quot;))
            else raise (OuterError(&quot;outer&quot;))
        with
            printfn &quot;Error1 %s&quot; str
    finally
        printfn &quot;Always print this.&quot;
</code></pre>
<h2>类和继承</h2>
<p>此示例是一个基本类，包含（1）本地 let 绑定，（2）属性，（3）方法和（4）静态成员。</p>
<pre><code class="language-fsharp">type Vector(x: float, y: float) =
    let mag = sqrt(x * x + y * y) // (1)
    member this.X = x // (2)
    member this.Y = y
    member this.Mag = mag
    member this.Scale(s) = // (3)
        Vector(x * s, y * s)
    static member (+) (a: Vector, b: Vector) = // (4)
        Vector(x.X + b.X, a.Y + b.Y)
</code></pre>
<p>从派生类调用基类。</p>
<pre><code class="language-fsharp">type Animal() =
    member __.Reset() = ()

type Dog() = 
    inherit Animal()
    member __.Run() =
        base.Reset()
</code></pre>
<p>上传表示为 :&gt; 运算符。</p>
<pre><code class="language-fsharp">let dog = Dog()
let animal = dog :&gt; Animal
</code></pre>
<p>如果转换在运行时未成功，则动态向下转换（ :?&gt; ）可能会抛出 InvalidCastException。</p>
<pre><code class="language-fsharp">let shouldBeDog = animal :?&gt; Dog
</code></pre>
<h2>接口和对象表达式</h2>
<p>声明 IVector 接口并在 Vector' 中实现它。</p>
<pre><code class="language-fsharp">type IVector
    abstract Scale : float -&gt; IVector

type Vector'(x, y) = 
    interface IVector with
        member __.Scale(s) =
            Vector'(x * s, y * s) :&gt; IVector
    member __.X = x
    member __.Y = y
</code></pre>
<p>实现接口的另一种方法是使用对象表达式。</p>
<pre><code class="language-fsharp">type ICustomer =
    abstract Name : string
    abstract Age : int

let createCustomer name age = 
    { new ICustomer with
        member __.Name = name
        member __.Age = age }
</code></pre>
<h2>活动模式</h2>
<p>完整的活动模式：</p>
<pre><code class="language-fsharp">let (|Even|Odd|) i = 
    if i % 2 = 0 then Even else Odd

let testNumber i = 
    match i with
    | Even -&gt; printfn &quot;%d is even&quot; i
    | Odd -&gt; printfn &quot;%d is odd&quot; i
</code></pre>
<p>参数化活动模式：</p>
<pre><code class="language-fsharp">let (|DivisibleBy|_|) by n =
    if n % by = 0 then Some DivisibleBy else None

let fizzBuzz = function
    | DivisibleBy 3 &amp; DivisibleBy 5 -&gt; &quot;FizzBuzz&quot;
    | DivisibleBy 3 -&gt; &quot;Fizz&quot;
    | DivisibleBy 5 -&gt; &quot;Buzz&quot;
    | i -&gt; string i
</code></pre>
<p>部分活动模式共享参数化模式的语法，但它们的主动识别器只接受一个参数。</p>
<h2>编译器指令</h2>
<p>将另一个 F# 源文件加载到 FSI 中。</p>
<pre><code class="language-fsharp">#load &quot;../lib/StringParsing.fs&quot;
</code></pre>
<p>引用.NET程序集（建议使用/符号以实现Mono兼容性）。</p>
<pre><code class="language-fsharp">#r &quot;../lib/FSharp.Markdown.dll&quot;
</code></pre>
<p>在程序集搜索路径中包含目录。</p>
<pre><code class="language-fsharp">#I &quot;../lib&quot;
#r &quot;FSharp.Markdown.dll&quot;
</code></pre>
<p>其他重要指令是 FSI（INTERACTIVE）中的条件执行和查询当前目录（ <strong>SOURCE_DIRECTORY</strong> ）。</p>
<pre><code class="language-fsharp">#if INTERACTIVE
let path = __SOURCE_DIRECTORY__ + &quot;../lib&quot;
#else
let path = &quot;../../../lib&quot;
#endif
</code></pre>

            </div>
        </div>
        </div>
        </div>
    </body>

</html>
