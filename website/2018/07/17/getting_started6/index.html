<h2>OCaml简介第6部分</h2>
<p>译自：https://qiita.com/zenwerk/items/97d370d457008d8f01de</p>
<h3>标记的参数</h3>
<h4>〜标签名称：</h4>
<ul>
<li>你可以命名这个参数。</li>
<li>如果你给一个标签名称，你可以改变你喜欢的参数的顺序。</li>
</ul>
<pre><code class="language-ocaml">(* 使用带标签的参数定义函数 *)

# let rec range ~first: a  ~last: b = 
  if a &gt; b then []
  else a :: range ~first: (a + 1) ~last: b;;
  
(* 函数类型上的标签类型 *)
val range : first:int -&gt; last:int -&gt; int list = &lt;fun&gt;

(* 指定标签名称函数应用程序 *)

# range ~first: 1 ~last: 10;;

- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 

# range ~last: 10 ~first: 1;;

- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 

(* 除非指定了标签名称，否则按标签名称定义应用 *) 

# range 1 10;;
- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]

# range 10 1;;
- : int list = []
</code></pre>
<ul>
<li>〜hoge：○○ ○○ 是可选的</li>
</ul>
<pre><code class="language-ocaml"># let rec range ~first ~last = 
  if first &gt; last then []
  else first :: range (first + 1) last;;
val range : first:int -&gt; last:int -&gt; int list = &lt;fun&gt;
</code></pre>
<h4>可选参数</h4>
<p>?标签名称：（pattern =表达式）</p>
<p>与Python的家伙相同的功能。</p>
<pre><code class="language-ocaml">(* 默认值1给出步骤值 *)

# let rec range ?(step = 1) a b = 
  if a &gt; b then []
  else a :: range ~step (a + step) b;;
val range : ?step:int -&gt; int -&gt; int -&gt; int list = &lt;fun&gt;

(* 函数应用 *)
# range 1 10;;

- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]

(* 因为它在调用时指定了标签 *)

# range 1 10 ~step:2;;
- : int list = [1; 3; 5; 7; 9]
# range 1 ~step:3 10;;
- : int list = [1; 4; 7; 10]

# range 2 1 10;;
Error: The function applied to this argument has type ?step:int -&gt; int list
This argument cannot be applied without label
</code></pre>
<h4>关于可选参数的说明</h4>
<h5>在选项参数后面准备一个无标签的参数</h5>
<p>如果选项参数在函数的结尾，则它变成了不能省略的选项参数，所以没有任何意义。</p>
<pre><code class="language-ocaml">(**
 * 我想定义一个函数，返回常量1 ....。
 * 如果选项参数在最后，我会收到警告
 *)
# let f ?(x=1) = x;;
Warning 16: this optional argument cannot be erased.
val f : ?x:int -&gt; int = &lt;fun&gt;
(* 1函数返回我以为它返回一个函数，接收*选项参数返回正在currying
 *)
# f;;
- : ?x:int -&gt; int = &lt;fun&gt;

(* 最后这么糟糕，不要添加无标签的参数 *)
# let f ?(x=1) () = x;;
val f : ?x:int -&gt; unit -&gt; int = &lt;fun&gt;
# f;;
- : ?x:int -&gt; unit -&gt; int = &lt;fun&gt;
# f();;
- : int = 1
</code></pre>
<h4>选项参数实体</h4>
<p>可选参数是用 'a option 实现的</p>
<p>如果你没有指定默认值，并写入它，尝试执行，你会得到一个错误，如下所示</p>
<pre><code class="language-ocaml"># let rec range ?step a b =
    if a &gt; b then []
    else a :: range ~step (a+step) b;;
(* 'a option type error is occurring  *)
Error: This expression has type 'a option
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a option
</code></pre>
<p>因此，在这种情况下，None 加 'a Some 来模式匹配</p>
<pre><code class="language-ocaml">
(* 与选项类型匹配的模式 *)

# let rec range ?step a b =
    let s = match step with None -&gt; 1 | Some s -&gt; s in
    if a &gt; b then [] else a :: range (a + s) b;;
val range : ?step:int -&gt; int -&gt; int -&gt; int list = &lt;fun&gt;

# range 1 10;;
- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
</code></pre>
<h4>多态变种</h4>
<h5>`Constructor</h5>
<p>一种机制，可以为多种变体类型使用通用的构造函数。</p>
<p>消除 “1构造函数&lt;=&gt; 1变体” 的限制。</p>
<pre><code class="language-ocaml"># `Hoge;;
- : [&gt; `Hoge ] = `Hoge
# `Hoge 2;;
- : [&gt; `Hoge of int ] = `Hoge 2
# `Hoge `Fuga;;
- : [&gt; `Hoge of [&gt; `Fuga ] ] = `Hoge `Fuga
</code></pre>
<h4>函数返回多态变种</h4>
<pre><code class="language-ocaml"># let f b = if b then `Hoge else `Fuga;;
val f : bool -&gt; [&gt; `Fuga | `Hoge ] = &lt;fun&gt;
</code></pre>
<pre><code class="language-ocaml"># let hoge = function
  | `Hoge -&gt; &quot;hoge&quot;
  | `Fuga -&gt; &quot;fuga&quot;
  | `Piyo -&gt; &quot;piyo&quot;;;
val hoge : [&lt; `Fuga | `Hoge | `Piyo ] -&gt; string = &lt;fun&gt;
</code></pre>
<h4>多态变种的类型方案</h4>
<p>[&gt; ...] , [&lt;...] 是类型方案 (同 `a)</p>
<p>[&gt; ..] 和 [&lt; ..] 它被视为有限制的类型变量。</p>
<p>在 [&gt; ...] 的情况下
[&gt; 可以解释为 “包含多态变种” 或更高。</p>
<pre><code class="language-ocaml">(* 
 * 可以接受任何东西的多相变体列表
 *)
# let  a : [&gt;] list = [`Fuga; `Piyo];;
val a : [&gt; `Fuga | `Piyo ] list = [`Fuga; `Piyo]

# a @ [`Asdf];;
- : [&gt; `Asdf | `Fuga | `Piyo ] list = [`Fuga; `Piyo; `Asdf]
</code></pre>
<p>在 [&lt;...] 中</p>
<p>[&lt; 可以被解释为“在所包含的多相变体类型中”。</p>
<pre><code class="language-ocaml">(* `Hoge,`within Fuga *)
# let f = function
  | `Hoge -&gt; &quot;hoge&quot;
  | `Fuga -&gt; &quot;fuga&quot;;;
val f : [&lt; `Fuga | `Hoge ] -&gt; string = &lt;fun&gt;

(* `Hoge, type within Fuga *)
# type type_A = [`Hoge | `Fuga];;
type type_A = [ `Fuga | `Hoge ]
# let a:type_A = `Hoge;;
val a : type_A = `Hoge
# f a;;
- : string = &quot;hoge&quot;

(* `Hoge,`Fuga or more types *)
# type type_B = [`Hoge | `Fuga | `Piyo];;
type type_B = [ `Fuga | `Hoge | `Piyo ]

(* `I'm Hoge type_B is `Hoge, `Fuga or more types *)
# let b:type_B = `Hoge;;
val b : type_B = `Hoge
# f b;; (* type error　*)
Error: This expression has type type_B but an expression was expected of type
         [&lt; `Fuga | `Hoge ]
       The second variant type does not allow tag(s) `Piyo
</code></pre>
<h4>多态变体类型的定义</h4>
<p>[&gt; ..] [&lt;..] 无法使用的模式</p>
<p>type hoge = [<code>Hoge |</code>Fuga |...]</p>
<p>声明一个类型变量 [&gt; ..] 和 [&lt;..] 定义一个模式</p>
<p>type 'a hoge = [&gt; `Hoge ...] as' a</p>
<pre><code class="language-ocaml"># type hoge = [`Hoge | `Fuga];;
type hoge = [ `Fuga | `Hoge ]

# type 'a hoge = [&gt; `Hoge] as 'a;;
type 'a hoge = 'a constraint 'a = [&gt; `Hoge ]

# type 'a hoge = [&lt; `Hoge] as 'a;;
type 'a hoge = 'a constraint 'a = [&lt; `Hoge ]

(* 类型定义可以重用 *)
# type hoge' = [hoge | `Piyo];;
type hoge' = [ `Fuga | `Hoge | `Piyo ]
</code></pre>
<h4>递归定义多相变量</h4>
<h5>type 'a mylist = Nil | Cons of 'a * 'a mylist 我们将其定义为多相变量</h5>
<ul>
<li>首先按顺序定义它，并检查Valiant类型发生了什么</li>
</ul>
<pre><code class="language-ocaml">（*通过定义来查看价格类型的变化*）
# let l1 = `Nil;;
val l1 : [&gt; `Nil ] = `Nil
# let l2 = `Cons(1, `Nil);;
val l2 : [&gt; `Cons of int * [&gt; `Nil ] ] = `Cons (1, `Nil)

（*你不能获得泛型类型定义*）
# let l3 = `Cons(2, `Cons(1, `Nil));;
val l3 : [&gt; `Cons of int * [&gt; `Cons of int * [&gt; `Nil ] ] ] =
  `Cons (2, `Cons (1, `Nil))
</code></pre>
<ul>
<li>如果你写一个执行任意列表处理的函数，你应该能够获得列表的通用术语类型定义...</li>
</ul>
<pre><code class="language-ocaml">(* 递归Variant类型的类型定义是...？ *)
# let rec length = function
  | `Nil -&gt; 0
  | `Cons (a, l) -&gt; 1 + length l;;
(*
* [...]因为'a已被赋予变体类型定义的别名
*这个别名'a出现在[...]中，原来是一个递归的定义
*'由b给出的类型变量是一个也可以看出哪个是固定的类型
*)

val length : ([&lt; `Cons of 'b * 'a | `Nil ] as 'a) -&gt; int = &lt;fun&gt;
</code></pre>
<pre><code class="language-ocaml">(* 函数在列表中选择*的最大值 *)
# let rec max_list = function
  | `Cons(x, `Nil) -&gt; x
  | `Cons(x, `Cons(y, l)) -&gt;
    if x &lt; y then max_list (`Cons(y, l)) else max_list (`Cons(x, l));;

(*
* [.. [..]] 是因为它的形式，可以看出长度大于或等于1
*)
val max_list : [ `Cons of 'a * ([&lt; `Cons of 'a * 'b | `Nil ] as 'b) ] -&gt; 'a = &lt;fun&gt;
</code></pre>
<h4>注意多相变异型</h4>
<h5>注意 &quot;&amp;&quot;</h5>
<p>如果多态变体＆出来，它表明，它输入失败</p>
<p>例如，int＆float指示表示int和float，不能实现</p>
<p>那么，在这种情况下，您应该查看函数定义等</p>
<pre><code class="language-ocaml"># let f = function `A x -&gt; x+1 | `B -&gt; 2;;
val f : [&lt; `A of int | `B ] -&gt; int = &lt;fun&gt;
# let g = function `A x -&gt; int_of_float x+1 | `B -&gt; 2;;
val g : [&lt; `A of float | `B ] -&gt; int = &lt;fun&gt;

(*
*返回不正确的类型[int＆float]
* hoge＆fuga是一个不可行的类型，所以下面的类型定义是真实的[&lt;`B] - &gt; Int
*)

# let f_or_g b = if b then f else g;;
val f_or_g : bool -&gt; [&lt; `A of int &amp; float | `B ] -&gt; int = &lt;fun&gt;
</code></pre>
<h4>使用点</h4>
<p>练习多相变量的正确使用所必需的。</p>
<p>在很多情况下，应该使用正常的变体来完成。</p>
<h4>奖励：你有多态记录吗？</h4>
<p>如果有多相变量，是否还有多态记录（如``hoge：int'）？ 我想，但没有这样的事情。</p>
<p>相反，OCaml对象可以提供等效的功能。</p>
<p>然而，对象没有模式匹配，所以说它用得不多。</p>
