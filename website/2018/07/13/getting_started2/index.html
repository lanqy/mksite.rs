<!--
 * @Author: Leland
 * @Date: 2019-12-27 15:59:00
 * @Description: Description
 -->
<!doctype html>
<html>

    <head>
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui" />
        <title>OCaml简介第2部分</title>
        <link href="/css/style.css" rel="stylesheet" />
        <meta name="description" content="OCaml简介第2部分">
    </head>

    <body>
        <div>
        <div>
        <header class="header">
            <div class="container header-wrap">
                <h1 class="site-name">
                    <a href="/">
                        首页
                    </a>
                </h1>
                <ul class="nav">
                    {{navs}}
                </ul>
            </div>
        </header>
        </div>
        <div class="container main">
        <div class="page-body">
            <div class="markdown-body">
                <h2>OCaml简介第 2 部分</h2>
<p>译自：https://qiita.com/zenwerk/items/603bd383fe5c6b8cace3</p>
<h3>递归多层数据结构。</h3>
<p>列表类型</p>
<pre><code class="language-ocaml"># [1;2;3;4;5];;
- : int list = [1; 2; 3; 4; 5]
# [&quot;a&quot;; &quot;b&quot;; &quot;c&quot;];;
- : string list = [&quot;a&quot;; &quot;b&quot;; &quot;c&quot;]
(* 不同的类型不能存在于同一个列表 *)
# [1; &quot;a&quot;];;
Error: This expression has type string but an expression was expected of type int
</code></pre>
<h3>将值添加到列表的开头</h3>
<p>使用consus操作符(::)。</p>
<p>右结合</p>
<pre><code class="language-ocaml"># 1 :: [2; 3; 4];;
- : int list = [1; 2; 3; 4]

(* 右結合 *)
# 1 :: 2 :: [3; 4];;
- : int list = [1; 2; 3; 4]
</code></pre>
<h3>列表合并</h3>
<p>使用 @ 。</p>
<pre><code class="language-ocaml"># [] @ [];;
- : 'a list = []
# [1] @ [2; 3];;
- : int list = [1; 2; 3]
# [&quot;asdf&quot;; &quot;hoge&quot;] @ [&quot;fuga&quot;];;
- : string list = [&quot;asdf&quot;; &quot;hoge&quot;; &quot;fuga&quot;]
</code></pre>
<h3>模式匹配</h3>
<p>match 表达式</p>
<p>match 表达式 with 模式1 - &gt;表达式 | 模式2 - &gt;表达式...</p>
<p>找到整数列表的总和的例子:</p>
<pre><code class="language-ocaml"># let rec total l =
    match l with
      [] -&gt; 0
    | h :: rest -&gt; h + (total rest);;
val total : int list -&gt; int = &lt;fun&gt;
# total [1; 2; 3; 4; 5];;
- : int = 15
</code></pre>
<p>反转列表的函数示例:</p>
<pre><code class="language-ocaml"># let reverse l =
    let rec innerReverse l1 l2 =
      match l1 with
      | [] -&gt; l2
      | h :: rest -&gt; innerReverse rest (h :: l2)
    in
    innerReverse l [];;
val reverse : 'a list -&gt; 'a list = &lt;fun&gt;
# reverse [1; 2; 3; 4];;
- : int list = [4; 3; 2; 1]
</code></pre>
<h3>function 表达式</h3>
<p>fun 和 match 通过组合定义一个匿名函数</p>
<p>function 模式1 - &gt; 表达式 | 模式2 - &gt; 表达式...</p>
<p>上面整数列表的总和的例子可以改写如下：</p>
<p>当使用最后一个参数进行模式匹配时方便，并且该参数仅用于模式匹配</p>
<pre><code class="language-ocaml"># let rec total = function
    [] -&gt; 0
  | h :: rest -&gt; h + (total rest);;
val total : int list -&gt; int = &lt;fun&gt;
# total [1; 2; 3; 4; 5];;
- : int = 15
</code></pre>
<h3>map 函数的例子</h3>
<pre><code class="language-ocaml"># let rec map fn = function
    | [] -&gt; []
    | h :: rest -&gt; fn h :: map fn rest;;
val map : ('a -&gt; 'b) -&gt; 'a list -&gt; 'b list = &lt;fun&gt;
# map (fun x -&gt; x + 1) [1; 2; 3; 4];;
- : int list = [2; 3; 4; 5]
</code></pre>
<h3>fold (折叠)函数例子</h3>
<pre><code class="language-ocaml">(* 左fold *)
# let rec foldl fn acc l =
    match l with
    | [] -&gt; acc
    | h :: rest -&gt; foldl fn (fn acc h) rest;;

(* 用于查找列表长度的 fold 示例 *)
# foldl (fun acc x -&gt; acc + 1) 0 [1; 2; 3];;
- : int = 3

(* 右fold *)
# let rec foldr fn l acc =
    match l with
    | [] -&gt; acc
    | h :: rest -&gt; fn h (foldr fn rest acc);;
val foldr : ('a -&gt; 'b -&gt; 'b) -&gt; 'a list -&gt; 'b -&gt; 'b = &lt;fun&gt;
</code></pre>
<h3>模式匹配守卫子句</h3>
<p>match 表达式 with 模式1 when 真/假表达式 - &gt;表达式| ...</p>
<p>使用 when。</p>
<h3>注意：match，function 中没有关闭符号</h3>
<p>在match with 和 function 上没有结束符号。</p>
<p>因此，当模式匹配嵌套时，必须用（）等括起来</p>
<h3>数据结构</h3>
<h4>记录（record）</h4>
<p>C语言结构，数据结构等同于 Python 字典。</p>
<p>命名元素名称。</p>
<h4>记录定义</h4>
<ul>
<li>type name = {field name：type; ...}</li>
<li>字段 - &gt; 名称和值对</li>
<li>请注意，字段名称不能与其他记录重复</li>
</ul>
<pre><code class="language-ocaml"># type student = {name: string; id: int};;
type student = { name : string; id : int; }
</code></pre>
<h4>创建记录</h4>
<ul>
<li>{Field name = value; ...}</li>
</ul>
<pre><code class="language-ocaml"># let s = {name = &quot;hoge&quot;; id = 1};;
val s : student = {name = &quot;hoge&quot;; id = 1}
</code></pre>
<h3>记录转移</h3>
<p>创建一个新的记录值，而不是覆盖现有的值。</p>
<p>{记录 with 字段名称 = 值; ...}</p>
<pre><code class="language-ocaml"># let s2 = {s with name = &quot;fuga&quot;};;
val s2 : student = {name = &quot;fuga&quot;; id = 1}
</code></pre>
<h3>变体</h3>
<p>数据结构代表案例分类。</p>
<pre><code class="language-ocaml">type name =
  | 构造函数 [ of &lt;type&gt; [* &lt;type&gt;]... ]
  | 构造函数 [ of &lt;type&gt; [* &lt;type&gt;]... ]
  | ...
</code></pre>
<ul>
<li>构造函数以英文大写字母开头</li>
<li>of 是构造函数所需的参数类型</li>
<li>of int * int 参数不是一组 int ，两个 int</li>
<li>of (int * int) 参数是一对 int</li>
</ul>
<p>以下是四种数字的变体类型：</p>
<pre><code class="language-ocaml"># type figure =
  | Point
  | Circle of int
  | Rectangle of int * int (* 两个 int 类型的参数，不是元组 *)
  | Square of int;;
type figure = Point | Circle of int | Rectangle of int * int | Square of int

# let c = Circle 4;;
val c : figure = Circle 4
# let figs = [Point; Rectangle (1, 1); c];;
val figs : figure list = [Point; Rectangle (1, 1); Circle 4]
</code></pre>
<h3>变体的模式匹配</h3>
<h4>function | 构造函数的参数 -&gt; | ...</h4>
<p>省略参数部分意味着没有参数构造函数。</p>
<pre><code class="language-ocaml">(* 计算图形面积的例子 *)
# let area = function
  | Point -&gt; 0
  | Circle r -&gt; r * r * 3
  | Rectangle (x, y) -&gt; x * y
  | Square x -&gt; x * x;;
val area : figure -&gt; int = &lt;fun&gt;
# area c;;
- : int = 48
</code></pre>
<h3>多态变体类型</h3>
<ul>
<li>可以使用类型变量（ 'a 等）来定义变体类型，</li>
<li>它也被称为带参数的参数。</li>
<li>例如，'a list 可以使用多态变量来表示。</li>
</ul>
<pre><code class="language-ocaml"># type 'a mylist =
  | Nil
  | Cons of 'a * 'a mylist;;
type 'a mylist = Nil | Cons of 'a * 'a mylist
# Nil;;
- : 'a mylist = Nil

(* 表示一个整数列表 *)
# Cons(1, Nil);;
- : int mylist = Cons (1, Nil)

(* 表示字符列表 *)
# Cons('a', Cons('b', Nil));;
- : char mylist = Cons ('a', Cons ('b', Nil))
</code></pre>
<h3>Optional</h3>
<p>通常说可选，表明这些情况下没有值</p>
<pre><code class="language-ocaml"># type 'a option =
  | None
  | Some of 'a;;
type 'a option = None | Some of 'a
</code></pre>
<p>使用可选的示例</p>
<pre><code class="language-ocaml"># let fact n =
    let rec fact' n = if n = 0 then 1 else n * fact' (n - 1) in
    if n &lt; 0 then None else Some (fact' n);;
val fact : int -&gt; int option = &lt;fun&gt;
# fact 3;;
- : int option = Some 6
# fact (-10);;
- : int option = None
</code></pre>
<h3>递归变体类型</h3>
<p>在构造函数中 of 下面是它自己的类型出现的变体类型</p>
<h4>二叉树的例子</h4>
<pre><code class="language-ocaml"># type 'a btree =
  | Leaf
  | Node of 'a * 'a btree * 'a btree;;
type 'a btree = Leaf | Tree of 'a * 'a btree * 'a btree

# Node(1, Node(1, Leaf, Leaf), Node(1, Node(1, Leaf, Leaf), Leaf));;
- : int btree =
Node (1, Node (1, Leaf, Leaf), Node (1, Node (1, Leaf, Leaf), Leaf))
</code></pre>
<p>查找树的元素数量和高度的函数示例</p>
<pre><code class="language-ocaml"># let tr = Node(1, Node(1, Leaf, Leaf), Node(1, Node(1, Leaf, Leaf), Leaf));;  
val tr : int btree =
  Node (1, Node (1, Leaf, Leaf), Node (1, Node (1, Leaf, Leaf), Leaf))

(* 用于查找高度的函数 *)
# let rec height = function
  | Leaf -&gt; 0
  | Node(_, left, right) -&gt; 1 + max (height left) (height right);;
val height : 'a btree -&gt; int = &lt;fun&gt;
# height tr;;
- : int = 3

(* 用于查找元素数目的函数 *)
# let rec size = function
  | Leaf -&gt; 0
  | Node (_, left, right) -&gt; 1 + size left + size right;;
val size : 'a btree -&gt; int = &lt;fun&gt;
# size tr;;
- : int = 4
</code></pre>
<h4>二叉搜索树的例子</h4>
<ul>
<li>添加元素</li>
</ul>
<pre><code class="language-ocaml"># let rec insert x = function
  | Leaf -&gt; Node(x, Leaf, Leaf)
  | Node(k, left, right) -&gt;
      if x &lt; k then Node(k, insert x left, right)
      else Node(k, left, insert x right);;
val insert : 'a -&gt; 'a btree -&gt; 'a btree = &lt;fun&gt;
</code></pre>
<ul>
<li>搜索元素</li>
</ul>
<pre><code class="language-ocaml"># let rec mem x = function
  | Leaf -&gt; false
  | Node(k, left, right) -&gt;
      if x &lt; k then mem x left
      else if x = k then true
      else mem x right;;
val mem : 'a -&gt; 'a btree -&gt; bool = &lt;fun&gt;
</code></pre>
<ul>
<li>使用例子</li>
</ul>
<pre><code class="language-ocaml"># let tr = Leaf;;
val tr : 'a btree = Leaf
# tr;;
- : 'a btree = Leaf
# insert 10 tr;;
- : int btree = Node (10, Leaf, Leaf)
# let tr = insert 10 tr;;
val tr : int btree = Node (10, Leaf, Leaf)
# let tr = insert 5 tr;;
val tr : int btree = Node (10, Node (5, Leaf, Leaf), Leaf)
# let tr = insert 20 tr;;
val tr : int btree = Node (10, Node (5, Leaf, Leaf), Node (20, Leaf, Leaf))
# mem 5 tr;;
- : bool = true
# mem 15 tr;;
- : bool = false
</code></pre>
<h3>玫瑰树的一个例子</h3>
<p>玫瑰树是元素数量未知的树。</p>
<p>它可以被认为是与 UNIX 相同的目录结构。</p>
<ul>
<li>类型定义</li>
</ul>
<pre><code class="language-ocaml">(* 由于子元素的数量是不确定的，节点的元素是列表 *)
# type 'a rosetree = RLeaf | RNode of 'a * 'a rosetree list;;
type 'a rosetree = RLeaf | RNode of 'a * 'a rosetree list
</code></pre>
<p>XML作为玫瑰树</p>
<ul>
<li>类型定义</li>
</ul>
<p>因为它是 XML ，叶子也没有价值 - &gt;（'b option）</p>
<pre><code class="language-ocaml">(* 'a 标记, 'b 值 *)
# type ('a, 'b) xml = XLeaf of 'b option | XNode of 'a * ('a, 'b) xml list;;
type ('a, 'b) xml = XLeaf of 'b option | XNode of 'a * ('a, 'b) xml list
</code></pre>
<p>对XML数据结构进行字符串化的函数</p>
<p>递归XML（Rose Tree）包含一个递归数据结构的列表</p>
<p>它是相互递归的定义</p>
<pre><code class="language-ocaml"># let rec string_of_xml = function
  | XNode(tag, xml_list) -&gt; &quot;&lt;&quot; ^ tag ^ &quot;&gt;&quot; ^ string_of_xmllist xml_list ^ &quot;&lt;/&quot; ^ tag ^ &quot;&gt;&quot;
  | XLeaf None -&gt; &quot;&quot;
  | XLeaf(Some s) -&gt; s
  and
  string_of_xmllist = function
  | [] -&gt; &quot;&quot;
  | xml :: rest -&gt; string_of_xml xml ^ string_of_xmllist rest;;
val string_of_xml : (string, string) xml -&gt; string = &lt;fun&gt;
val string_of_xmllist : (string, string) xml list -&gt; string = &lt;fun&gt;
</code></pre>
<h3>无限的列</h3>
<h4>整数的无限列的例子</h4>
<pre><code class="language-ocaml"># type intseq = Cons of int * (int -&gt; intseq);;
type intseq = Cons of int * (int -&gt; intseq)
</code></pre>
<ul>
<li>无限列的示例递增</li>
</ul>
<pre><code class="language-ocaml"># let rec f x = Cons(x+1, f);;
val f : int -&gt; intseq = &lt;fun&gt;
# f 0;;
- : intseq = Cons (1, &lt;fun&gt;)
# f 100;;
- : intseq = Cons (101, &lt;fun&gt;)
</code></pre>
<ul>
<li>
<p>如果返回值的 x 是下一个元素</p>
<p>通过给x作为参数，我们得到元素的顺序</p>
</li>
</ul>
<pre><code class="language-ocaml"># let Cons(x, f) = f 0;;
val x : int = 1
val f : int -&gt; intseq = &lt;fun&gt;
# let Cons(x, f) = f x;;
val x : int = 2
val f : int -&gt; intseq = &lt;fun&gt;
# let Cons(x, f) = f x;;
val x : int = 3
val f : int -&gt; intseq = &lt;fun&gt;
</code></pre>
<ul>
<li>获取第 N 个元素函数</li>
</ul>
<pre><code class="language-ocaml"># let rec nthseq n (Cons(x, f)) =
    if n = 1 then x
    else nthseq (n-1) (f x);;
val nthseq : int -&gt; intseq -&gt; int = &lt;fun&gt;
# nthseq 10 (f 0);;
- : int = 10
</code></pre>

            </div>
        </div>
        </div>
        </div>
    </body>

</html>
