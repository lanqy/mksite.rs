<!--
 * @Author: Leland
 * @Date: 2019-12-27 15:59:00
 * @Description: Description
 -->
<!doctype html>
<html>

    <head>
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui" />
        <title>OCaml简介第4部分</title>
        <link href="/css/style.css" rel="stylesheet" />
        <meta name="description" content="OCaml简介第4部分">
    </head>

    <body>
        <div>
        <div>
        <header class="header">
            <div class="container header-wrap">
                <h1 class="site-name">
                    <a href="/">
                        首页
                    </a>
                </h1>
                <ul class="nav">
                    {{navs}}
                </ul>
            </div>
        </header>
        </div>
        <div class="container main">
        <div class="page-body">
            <div class="markdown-body">
                <h2>OCaml简介第4部分</h2>
<p>译自：https://qiita.com/zenwerk/items/244b84bee48bf61d2a51</p>
<h3>模块</h3>
<p>它是程序的一部分，但在OCaml中被称为结构。</p>
<p>所有OCaml库都作为模块（结构）提供。</p>
<h4>文件名称即是模块名称</h4>
<p>文件名 example.ml =&gt; 模块名称为 Example</p>
<h4>标准模块</h4>
<p>OCaml 内置模块</p>
<pre><code class="language-ocaml">(* 列表 *)
# List.length [1; 2; 3];;
- : int = 3
# let q = Queue.create ();;
val q : '_a Queue.t = &lt;abstr&gt;

(* 队列 *)
# Queue.add &quot;first&quot; q;;
- : unit = ()
# Queue.take q;;
- : string = &quot;first&quot;
# Queue.take q;;
Exception: Queue.Empty.

(* 数组 *)
# Array.make 3 'a';;
- : char array = [|'a'; 'a'; 'a'|]

(* 标准输出 *)
# Printf.printf &quot;%d, %x, %s\n&quot; 10 255 &quot;hoge&quot;;;
10, ff, hoge
- : unit = ()
</code></pre>
<h4>open 模块</h4>
<p>通过 open 打开模块可以省略模块名称</p>
<p>与 python 中 from hoge import * 类似</p>
<p>由于打开到当前源的模块的名称空间已扩展，因此只有在不困惑时才能打开它。</p>
<p>由于容器名称经常与函数名称重叠，因此不打开它们是正常的。</p>
<pre><code class="language-ocaml">(* 打开模块 *)
# open List;;
# length [1; 2; 3];;
- : int = 3

(* 覆盖函数名称 *)
# let length () = &quot;overload!&quot;;;
val length : unit -&gt; string = &lt;fun&gt;
# length ();;
- : string = &quot;overload!&quot;

(* 您可以通过指定模块名称来调用它 *)
# List.length [1; 2; 3];;
- : int = 3
</code></pre>
<p>顺便说一下，OCaml有一个名为Pervasives的模块，在启动时打开。</p>
<p>像abs和open_in这样的函数属于这个模块。</p>
<h4>模块定义</h4>
<p>模块名称以大写字母开头</p>
<h5>module 模块名 = struct 各种定义... end</h5>
<pre><code class="language-ocaml">(* 模块定义 *)
# module Hello = struct
    let message = &quot;Hello&quot;
    let hello () = print_endline message
  end;;
module Hello : sig val message : string val hello : unit -&gt; unit end
(* 调用 *)
# Hello.hello ();;
Hello
- : unit = ()
</code></pre>
<h4>签名</h4>
<h5>签名</h5>
<ul>
<li>sig ... end 周围的部分</li>
<li>整个模块的类型（类似）</li>
<li>表示模块的I / F（可以定义可访问模块的元素）</li>
</ul>
<h4>mli文件</h4>
<p>Hoge 模块的签名可以在 hoge.mli 文件中定义。</p>
<p>在文件中写一个签名</p>
<h5>签名定义</h5>
<ul>
<li>定义 =&gt; module type 签名名 = sig ... end</li>
<li>应用 =&gt; module 模块名 : 签名名 = 模块名或 struct ... end</li>
</ul>
<pre><code class="language-ocaml">(* message 元素可访问 *)
# Hello.message;;
- : string = &quot;Hello&quot;

(* message 定义未定义的签名 *)
# module type Hello_Sig =
    sig
      val hello: unit -&gt; unit
    end;;
module type Hello_Sig = sig val hello : unit -&gt; unit end

(* 给一个模块签名 *)
# module Hello2 : Hello_Sig = Hello;;
module Hello2 : Hello_Sig

(* 因为它不是签名, message 元素不可访问 *)
# Hello2.hello ();;
Hello
- : unit = ()
# Hello2.message;;
Error: Unbound value Hello2.message

(* 直接定义模块 *)
# module Hello3 : Hello_Sig = struct
    let hello () = print_endline &quot;Hello3!&quot;
  end;;
module Hello3 : Hello_Sig
# Hello3.hello ();;
Hello3!
- : unit = ()
# Hello3.message;;
Error: Unbound value Hello3.message
</code></pre>
<h4>抽象数据类型</h4>
<p>在签名定义中，省略 = ...用于类型定义（typ t = ...）</p>
<p>您可以隐藏定义的详细信息。</p>
<p>通过隐藏类型信息和实现，可以将该类型的操作限制为通过模块进行的操作。</p>
<p>防止意外操作。</p>
<pre><code class="language-ocaml">(* 签名定义 *)
# module type AbstTypeSig = sig
    type t (* 抽象数据类型 *)
    val get_t : int -&gt; t
    val print : t -&gt; unit
  end;;
module type AbstTypeSig =
  sig type t val get_t : int -&gt; t val print : t -&gt; unit end

(* 模块定义 *)
# module AbstTypeInt : AbstTypeSig = struct
    type t = int
    let get_t i = i
    let print t = print_int t
  end;;
module AbstTypeInt : AbstTypeSig

(* 如果返回值是一个抽象数据类型 &lt;abstr&gt; *)
# let t = AbstTypeInt.get_t 0;;
val t : AbstTypeInt.t = &lt;abstr&gt;
# AbstTypeInt.print t;;
0- : unit = ()

(* 
  抽象数据类型不能在外部处理
  AbstTypeInt.t 是一个真正的int，但是因为它隐藏着一个抽象的数据类型
  print_int 即使是作为参数引用
*)
# let () = print_int t;;
Error: This expression has type AbstTypeInt.t
       but an expression was expected of type int
</code></pre>
<h3>Functor</h3>
<p>通过应用参数动态生成参数的函数。</p>
<p>消除了多次定义不同模块的麻烦。</p>
<h4>使用 Functor</h4>
<h5>Functor应用程序 =&gt; Functor名称（模块化）</h5>
<h5>※模块化功能应用程序本身</h5>
<h4>处理集合 Set 模块示例</h4>
<p>标准模块的 Set 和 Queue 使用 functor</p>
<p>对于要处理的集合的元素，定义以下模块</p>
<ul>
<li>定义集合元素的模块</li>
<li>一个类型 t 表示一个集合的元素</li>
<li>比较元素类型t的大小的函数：compare: t -&gt; t -&gt; int</li>
</ul>
<p>将上述“元素类型模块”应用于 functor ，生成“该类型为元素的模块”。</p>
<pre><code class="language-ocaml">(* functor 应用 *)
# module IntSet = Set.Make (struct
    type t = int
    let compare i j = i - j
  end);;
module IntSet :
  sig
    type elt = int (* 元素我想作为元素类型对待 elt = int *)
    type t         (* 代表一个集合的类型是 IntSet.t 是一种抽象数据类型 *)
    val empty : t
    val is_empty : t -&gt; bool
    val mem : elt -&gt; t -&gt; bool
    val add : elt -&gt; t -&gt; t
    val singleton : elt -&gt; t
    val remove : elt -&gt; t -&gt; t
    val union : t -&gt; t -&gt; t
    val inter : t -&gt; t -&gt; t
    val diff : t -&gt; t -&gt; t
    val compare : t -&gt; t -&gt; int
    val equal : t -&gt; t -&gt; bool
    val subset : t -&gt; t -&gt; bool
    val iter : (elt -&gt; unit) -&gt; t -&gt; unit
    val fold : (elt -&gt; 'a -&gt; 'a) -&gt; t -&gt; 'a -&gt; 'a
    val for_all : (elt -&gt; bool) -&gt; t -&gt; bool
    val exists : (elt -&gt; bool) -&gt; t -&gt; bool
    val filter : (elt -&gt; bool) -&gt; t -&gt; t
    val partition : (elt -&gt; bool) -&gt; t -&gt; t * t
    val cardinal : t -&gt; int
    val elements : t -&gt; elt list
    val min_elt : t -&gt; elt
    val max_elt : t -&gt; elt
    val choose : t -&gt; elt
    val split : elt -&gt; t -&gt; t * bool * t
    val find : elt -&gt; t -&gt; elt
    val of_list : elt list -&gt; t
  end

(* 使用由 functor 生成的模块 *)
# open IntSet;;
# let s1 = add 2 (add 1 empty)
  and s2 = add 1 (add 3 empty);;
val s1 : IntSet.t = &lt;abstr&gt;
val s2 : IntSet.t = &lt;abstr&gt;
# mem 1 s1;;
- : bool = true
</code></pre>
<h4>Functor 的定义</h4>
<h5>module functor名称（参数名称：签名表达式）= 模块化表达式</h5>
<p>以下糖衣语法</p>
<h5>module functor名称 = functor（参数名称：签名表达式） -&gt; 模块化表达式</h5>
<p>定义 Set.Make 的一个简单 functor 的例子</p>
<pre><code class="language-ocaml">(* 签名定义 *)
module type ELEMENT = sig
  type t
  val compare: t -&gt; t -&gt; int
end

(* functor 定义 *)
module MakeSet (Element : ELEMENT) =
  struct
    type elt = Element.t
    type t = elt list

    let empty = []

    let mem x set = List.exists (fun y -&gt; Element.compare x y = 0) set

    let rec add elt = function
    | [] -&gt; [elt]
    | (x :: rest as s) -&gt;
        match Element.compare elt x with
        | 0 -&gt; s
        | r when r &lt; 0 -&gt; elt :: s
        | _ -&gt; x :: (add elt rest)

    let rec elements s = s
  end;;
</code></pre>
<h4>依赖类型</h4>
<ul>
<li>上述 functor 的返回值的签名如下</li>
<li>Functor（Element：ELEMENT） -&gt; 转换的描述在 sig ... end 中查看</li>
<li>type elt = Element.t 被写入正式参数的值包含在返回类型中</li>
<li>换句话说，返回值的类型根据给定的参数值（！= Type）而变化，</li>
<li>这被称为依赖类型</li>
</ul>
<pre><code class="language-ocaml">(* 返回顶层的值 *)
module type ELEMENT = sig type t val compare : t -&gt; t -&gt; int end
module MakeSet :
  functor (Element : ELEMENT) -&gt;
    sig
      type elt = Element.t
      type t = elt list
      val empty : 'a list
      val mem : Element.t -&gt; Element.t list -&gt; bool
      val add : Element.t -&gt; Element.t list -&gt; Element.t list
      val elements : 'a -&gt; 'a
    end
</code></pre>
<h4>functor 的信息隐藏</h4>
<p>像普通模块一样，您可以限制函数返回值的签名并隐藏内部实现。</p>
<h5>module functor名称（参数名称：输入签名表达式）：签名表达式返回 = 模块表达式</h5>
<p>通过指定要返回的签名表达式可以隐藏信息</p>
<pre><code class="language-ocaml">module MakeSet (Element : ELEMENT) :
  (* 签名表达式返回 *)
  sig
    type elt = Element.t
    type t (* 抽象数据类型 *)
    val mem : elt -&gt; t -&gt; bool
    val add : elt -&gt; t -&gt; t
    val elements : t -&gt; elt list
  end
  =
  (* 模块化 *)
  struct
    type elt = Element.t
    type t = elt list

    let empty = []

    let mem x set = List.exists (fun y -&gt; Element.compare x y = 0) set

    let rec add elt = function
    | [] -&gt; [elt]
    | (x :: rest as s) -&gt;
        match Element.compare elt x with
        | 0 -&gt; s
        | r when r &lt; 0 -&gt; elt :: s
        | _ -&gt; x :: (add elt rest)

    let rec elements s = s
  end;;

(* functor 表达式的返回值 *)
module MakeSet :
  functor (Element : ELEMENT) -&gt;
    sig
      type elt = Element.t
      type t
      val empty : t
      val mem : elt -&gt; t -&gt; bool
      val add : elt -&gt; t -&gt; t
      val elements : t -&gt; elt list
    end
</code></pre>
<p>比较上述函数应用方程的返回值签名公式</p>
<ul>
<li>before</li>
</ul>
<pre><code class="language-ocaml"># module StringSet = MakeSet(String);;
module StringSet :
  sig
    type elt = String.t
    type t = elt list
    val empty : 'a list
    val mem : String.t -&gt; String.t list -&gt; bool
    val add : String.t -&gt; String.t list -&gt; String.t list
    val elements : 'a -&gt; 'a
  end
</code></pre>
<ul>
<li>After</li>
</ul>
<pre><code class="language-ocaml"># module IntSet = MakeSet(struct
    type t = int
    let compare i j = i - j
  end);;
module IntSet :
  sig
    type elt = int
    type t (* 抽象数据类型 *)
    val empty : t
    val mem : elt -&gt; t -&gt; bool
    val add : elt -&gt; t -&gt; t
    val elements : t -&gt; elt list
  end

# Open IntSet;;
# let s1 = add 1 (add 2 empty)
  and s2 = add 3 (add 4 empty);;
val s1 : IntSet.t = &lt;abstr&gt; (* 抽象数据类型 *)
val s2 : IntSet.t = &lt;abstr&gt;

(* 当它是一个字符串 *)
# module StringSet = MakeSet(String);;
module StringSet :
  sig
    type elt = String.t
    type t = MakeSet(String).t (* 有隐藏的实现吗？ *)
    val empty : t
    val mem : elt -&gt; t -&gt; bool
    val add : elt -&gt; t -&gt; t
    val elements : t -&gt; elt list
  end

# open StringSet;;
# let s1 = add &quot;a&quot; (add &quot;b&quot; empty)
  and s2 = add &quot;c&quot; (add &quot;d&quot; empty);;
val s1 : StringSet.t = &lt;abstr&gt; (* 这是一个抽象的数据类型 *)
val s2 : StringSet.t = &lt;abstr&gt;
</code></pre>
<h4>签名的分解和定义（ with type ）</h4>
<p>签名表达式 with type 类型名 = 类型定义 and type ...</p>
<p>不要指定你希望 functor 直接用 sig ... end 返回的签名定义，而是要给它定义名称。</p>
<p>type elt = Element.t 部分</p>
<p>签名不能被定义为别名，因为它取决于伪参数名称</p>
<pre><code class="language-ocaml">module MakeSet (Element : ELEMENT) :
  (* 签名表达式返回 *)
  sig
    type elt = Element.t
    type t (* 抽象数据类型 *)
  end
  =
  struct ... end;;
</code></pre>
<h4>with type 语法使用</h4>
<pre><code class="language-ocaml">(* with type 类型定义替换 elt *)
# module type ElementWithType =
    sig
      type elt
      type t
      val empty : t
      val mem : elt -&gt; t -&gt; bool
      val add : elt -&gt; t -&gt; t
      val elements : t -&gt; elt list
    end;;

(* with type 定义 *)
# module type E2 = ElementWithType with type elt = int;;
module type E2 =
  sig
    type elt = int
    type t
    val empty : t
    val mem : elt -&gt; t -&gt; bool
    val add : elt -&gt; t -&gt; t
    val elements : t -&gt; elt list
  end
</code></pre>
<h3>批处理编译器和拆分编译</h3>
<p>编译器通过file =&gt; 批量编译器导出</p>
<p>以文件为单位创建一个目标文件Link =&gt; 分割编译</p>
<p>ocaml 的批处理编译器 =&gt; ocamlc（bytecode），ocamlopt（本地代码）</p>
<h4>统一编译</h4>
<pre><code class="language-ocaml">$ ocamlc -o output.name src1.ml src2.ml ...
</code></pre>
<h4>拆分编译</h4>
<ul>
<li>需要安排最后一个链接的 cmo 文件，以便名称解析成为可能</li>
<li>非标准库</li>
<li>链接时有必要明确指出文件名</li>
<li>nums.cma 等</li>
<li>-c 选项输出目标文件而不链接</li>
<li>-I 允许您指定包含 cmi，cmo 的目录</li>
</ul>
<pre><code class="language-ocaml">$ ocamlc -c mod1.ml
$ ocamlc -c mod2.ml
$ ocamlc -o output.name nums.cma mod1.cmo mod2.cmo
</code></pre>
<h4>mli文件</h4>
<p>mli 文件描述了相应的 .ml 签名</p>
<p>在编译时使用 ocamlc</p>
<p>用 ocamlc 编译 mli 文件</p>
<p>用 ocamlc -c编译ml文件</p>
<p>链接 cmo 与 ocamlc</p>
<pre><code class="language-ocaml">$ ocamlc mod.mli  # -c 没有选项要求
$ ocamlc -c mod.ml
$ ocamlc -c mod2.ml
$ ocamlc -o a.out mod.cmo mod2.cmo
</code></pre>

            </div>
        </div>
        </div>
        </div>
    </body>

</html>
