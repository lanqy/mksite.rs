<h2>OCaml简介第5部分</h2>
<p>译自：https://qiita.com/zenwerk/items/3844df72c5f4afb1782f</p>
<h3>面向对象的功能</h3>
<h4>类声明</h4>
<p>object ... end</p>
<p>OCaml实例变量的所有成员都是私有的</p>
<pre><code class="language-ocaml"># class point ini_x ini_y =
    object (self)  (* 自身の名前をつける, 自由なので this とかでも良い *)
      val mutable x = 0 (* 实例变量不能从外部访问 *)
      val mutable y = 0

      (*
       * 实例方法
       * method 方法名称 参数... = 表达式
       *)
      method set new_x new_y = begin x &lt;- new_x; y &lt;- new_y end
      method private print_x = print_int x (* 私有方法 *)

      (* 构造函数 *)
      initializer begin
        x &lt;- ini_x; y &lt;- ini_y
      end
    end;;
(* 签名 *)    
class point :
  int -&gt;
  int -&gt;
  object
    val mutable x : int
    val mutable y : int
    method private print_x : unit
    method set : int -&gt; int -&gt; unit
  end
</code></pre>
<h4>实例生成</h4>
<p>new 类名称</p>
<pre><code class="language-ocaml"># let p = new point;;
val p : point = &lt;obj&gt;
</code></pre>
<h4>调用实例方法</h4>
<p>实例#方法名称</p>
<pre><code class="language-ocaml"># p#set 1 2;;
- : unit = ()
</code></pre>
<h4>継承</h4>
<p>inherit 类名</p>
<p>以下类可以由 self 本身通过 super 访问父类。</p>
<pre><code class="language-ocaml">(* 打印坐标 *)
# class point_with_print x y =
    object (self)
      inherit point x y as super (* 访问父类的名称 *)
      method print = Printf.printf &quot;(%d, %d)\n&quot; x y
    end;;
class point_with_print :
  int -&gt;
  int -&gt;
  object
    val mutable x : int
    val mutable y : int
    method print : unit
    method private print_x : unit
    method set : int -&gt; int -&gt; unit
  end

(* 生成继承类的实例 *)
# let p = new point_with_print 1 1;;
val p : point_with_print = &lt;obj&gt;
# p#print;;
(1, 1)
- : unit = ()
</code></pre>
<h4>类类型</h4>
<h5>&lt;方法名称：类型 ...&gt;</h5>
<ul>
<li>对象的类型是方法类型的顺序</li>
<li>如果方法名称和类型的组合匹配，则认为是相同的对象类型</li>
<li>要检查一个类的类型，直接使用 let 定义对象而不使用 class。</li>
</ul>
<pre><code class="language-ocaml">(* 直接定义对象 *)
let obj = 
  object (self)
    val mutable x = 0
    val mutable y = 0
    method set new_x new_y = begin x &lt;- new_x; y &lt;- new_y end
  end;;

(* 显示类型 *)
val obj : &lt; set : int -&gt; int -&gt; unit &gt; = &lt;obj&gt;
(* 尝试调用实例方法 *)
# obj#set 1 2;;
- : unit = ()
</code></pre>
<h4>上面的 obj 类型是 &lt; set : int -&gt; int -&gt; unit &gt;</h4>
<p>换句话说，这意味着有一个方法设置int - &gt; int - &gt; unit。</p>
<p>具有满足这个定义的方法的类被认为是相同的对象类型。</p>
<pre><code class="language-ocaml">(* 定义上面与obj无关的类 *)
# class unrelated_class =
    object
      (* 定义一个显示x，y的方法集 *)
      method set x y = Printf.printf &quot;(%d, %d)\n&quot; x y
    end;;
class unrelated_class : object method set : int -&gt; int -&gt; unit end

(* 由于对象类型匹配，它们被放在同一个列表中 *)
# let obj2 = new unrelated_class;;
val obj2 : unrelated_class = &lt;obj&gt;
# [obj; obj2];;
- : unrelated_class list = [&lt;obj&gt;; &lt;obj&gt;]

(* 由于对象类型匹配，可以将其作为相同的返回值类型进行处理 *)
# let hoge x = if x then obj else new unrelated_class;;
val hoge : bool -&gt; unrelated_class = &lt;fun&gt;
# (hoge true)#set 1 2;;
- : unit = ()
# (hoge false)#set 1 2;;
(1, 2)
- : unit = ()
</code></pre>
<p>我个人觉得Java和Go的界面正在扮演OCaml的对象类型的角色。</p>
<h4>部分类型</h4>
<h5>部分类型=&gt;如果定义了部分对象类型的方法，则将其视为部分类型</h5>
<ul>
<li>示例：类型2是类型1的部分类型</li>
<li>类型1 =&gt; &lt;方法1：int - &gt; int，方法2：unit&gt;</li>
<li>类型2 =&gt; &lt;method1：int - &gt; int&gt;</li>
</ul>
<h4>CORATION（类型转换）</h4>
<p>（表达式：类型1：&gt;类型2）</p>
<p>将部分类型1转换为类型2。 它接近于Java中的上传。</p>
<pre><code class="language-ocaml">(* print_class1 是 print_class2 的部分类型 *)
# class print_class1 = object
    method print_1 = print_int 1
  end;;
class print_class1 : object method print_1 : unit end
# class print_class2 = object
    method print_1 = print_int 1
    method print_2 = print_int 2
  end;;
class print_class2 : object method print_1 : unit method print_2 : unit end

(* 由于对象类型不同，print_class 1和print_class 2不在同一个列表中 *)
# let obj_list = [new print_class1; new print_class2];;
Error: This expression has type print_class2
       but an expression was expected of type print_class1
       The second object type has no method print_2

(* 通过指导（类型转换）把它们放在同一个列表中 *)
# let obj_list = [new print_class1; (new print_class2 :&gt; print_class1)];;
val obj_list : print_class1 list = [&lt;obj&gt;; &lt;obj&gt;]

(* コアーションによって削ぎ落とされた情報は呼び出せない *)
# let [obj1; obj2] = obj_list;;
val obj1 : print_class1 = &lt;obj&gt;
val obj2 : print_class1 = &lt;obj&gt;

# obj1#print_1;; (* 可以调用 *)
1- : unit = ()
# obj2#print_2;; (* 不能被调用 *)
Error: This expression has type print_class1
       It has no method print_2
</code></pre>
<h4>多层对象类型</h4>
<p>表示满足部分类型的任意类型</p>
<ul>
<li>&lt;方法名称1：类型1; ...，方法名称n：类型n; ..&gt;</li>
<li>最后一个“..”是重要的</li>
<li>换句话说，它表示“各种其他”</li>
</ul>
<pre><code class="language-ocaml">
(* 定义接受多层对象类型的函数 *)
# let print1 print_obj = print_obj#print_1;;
val print1 : &lt; print_1 : 'a; .. &gt; -&gt; 'a = &lt;fun&gt;

(* 您可以接收满足部分类型的对象类型 *)
# print1 obj1;;
1- : unit = ()
# print1 obj2;;
1- : unit = ()
</code></pre>
<p>以上 &lt; print_1 : 'a; .. &gt; -&gt; 'a = <!-- raw HTML omitted --> 中的 -&gt; 'a 部分 'a 是一个类型变量 &lt; print_1 : 'a; .. &gt; 的别名</p>
<h4>关于多层次对象类型的参数类型的变化</h4>
<p>如果你给一个多层次的类型的参数</p>
<pre><code class="language-ocaml">(* 定义多层函数 *)
# let k1 a b = a and k2 a b = b;;
val k1 : 'a -&gt; 'b -&gt; 'a = &lt;fun&gt;
val k2 : 'a -&gt; 'b -&gt; 'b = &lt;fun&gt;

(* 请求相同类型的函数的返回值会更改该类型。 *)
# let f b = if b then k1 else k2;;
（*'a - &gt;'b - &gt;'a /'b 的类型是 'a - &gt;'a - &gt;'a *）
val f : bool -&gt; 'a -&gt; 'a -&gt; 'a = &lt;fun&gt;
</code></pre>
<p>当给出一个不是多层的类型的参数时</p>
<pre><code class="language-ocaml">(* 不同类型的函数 *)
# let k1' (a:int) (b:string) = a and k2' (a:int) (b:string) = b;;
val k1' : int -&gt; string -&gt; int = &lt;fun&gt;
val k2' : int -&gt; string -&gt; string = &lt;fun&gt;

（*
  *由于返回值的函数类型不同，因此不能作为返回值使用
  *统一的类型不能完成
 *）
# let f' b = if b then k1' else k2';;
Error: This expression has type int -&gt; string -&gt; string
       but an expression was expected of type int -&gt; string -&gt; int
       Type string is not compatible with type int
</code></pre>
<p>给定一个多层对象类型</p>
<pre><code class="language-ocaml">(* 多定义分层对象类型的函数 *)
# let print1' obj = obj#print_1 and print2' obj = obj#print_2;;
val print1' : &lt; print_1 : 'a; .. &gt; -&gt; 'a = &lt;fun&gt;
val print2' : &lt; print_2 : 'a; .. &gt; -&gt; 'a = &lt;fun&gt;

(* 当组合两个分层对象类型函数时 *)
# let f b = if b then print1' else print2';;
(*
 * 函数的返回值的类型为 &lt; print_1 : 'a; print_2 : 'a; .. &gt;
 * 换句话说，诸如合成每个多层对象类型的类型变成了
 *)
val f : bool -&gt; &lt; print_1 : 'a; print_2 : 'a; .. &gt; -&gt; 'a = &lt;fun&gt;

(* 函数调用 *)
# let a = f true;;
val a : &lt; print_1 : '_a; print_2 : '_a; _.. &gt; -&gt; '_a = &lt;fun&gt;
(* print_2 因为它没有类型错误 *)
# a new print_class1;;
Error: This expression has type print_class1
       but an expression was expected of type print_class2
       The first object type has no method print_2
(* OK, 因为它满足对象类型 *)
# a new print_class2;;
1- : unit = ()
</code></pre>
<h4>抽象方法·抽象类</h4>
<ul>
<li>定义假定稍后继承</li>
<li>抽象方法=&gt;具有空定义的方法</li>
<li>method virtual 方法 : 类型</li>
<li>抽象类=&gt;抽象方法的类定义</li>
</ul>
<pre><code class="language-ocaml">
(* 抽象类的定义 *)
# class virtual abstruct_print =
    object (self)
      method virtual print : unit (* 抽象方法 *)
    end;;
class virtual abstruct_print : object method virtual print : unit end

(* 继承抽象类 *)
# class print_hoge =
    object (self)
      inherit abstruct_print
      method print = Printf.printf &quot;hoge!\n&quot;
    end;;
class print_hoge : object method print : unit end
</code></pre>
<p>class virtual</p>
<h4>多阶段类（泛型）</h4>
<ul>
<li>定义用类型参数化的对象类。</li>
<li>类定义=&gt;定义一个同名的对象类型，而不仅仅是类</li>
<li>类型变量的声明是定义多层定义中的类类型所必需的</li>
<li>显式声明类型变量</li>
<li>请参阅中定义的类型变量</li>
</ul>
<h4>class [类型变量, ...] 类名称 object ... end</h4>
<p>定义一个可以填充任何类型值的堆栈（从官方网站引用）</p>
<pre><code class="language-ocaml"># class ['a] stack =
    object (self)
      val mutable list = ( [] : 'a list )  (* 实例变量 *)
      method push x = list &lt;- x :: list    (* 推入堆栈 *)
      method pop =                         (* 从堆栈中移除(pop) *)
        let result = List.hd list in
        list &lt;- List.tl list;
        result
      method peek = List.hd list     (* 堆栈峰值 *)
      method size = List.length list (* 堆栈的大小 *)
    end;;
class ['a] stack :
  object
    val mutable list : 'a list
    method peek : 'a
    method pop : 'a
    method push : 'a -&gt; unit
    method size : int
  end
</code></pre>
<p>使用多阶段类</p>
<pre><code class="language-ocaml">(* 生成堆栈的一个实例 *)
# let s = new stack;;
(* 用非约束状态的类型变量生成实例 *)
val s : '_a stack = &lt;obj&gt;
(* 添加一个浮点数 *)
# s#push 1.0;;
- : unit = ()
(* 类型变量 '_a 被绑定为浮点数 *)
# s;;
- : float stack = &lt;obj&gt;
</code></pre>
