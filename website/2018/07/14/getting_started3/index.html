<!--
 * @Author: Leland
 * @Date: 2019-12-27 15:59:00
 * @Description: Description
 -->
<!doctype html>
<html>

    <head>
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui" />
        <title>OCaml简介第3部分</title>
        <link href="/css/style.css" rel="stylesheet" />
        <meta name="description" content="OCaml简介第3部分">
    </head>

    <body>
        <div>
        <div>
        <header class="header">
            <div class="container header-wrap">
                <h1 class="site-name">
                    <a href="/">
                        首页
                    </a>
                </h1>
                <ul class="nav">
                    {{navs}}
                </ul>
            </div>
        </header>
        </div>
        <div class="container main">
        <div class="page-body">
            <div class="markdown-body">
                <h2>OCaml简介第3部分</h2>
<p>译自：https://qiita.com/zenwerk/items/bfc1978718b5da3f463b</p>
<h3>异常处理</h3>
<p>它在您除以零或指定一个不存在的文件时发生。</p>
<pre><code class="language-ocaml"># 1/0;;
Exception: Division_by_zero.
# open_in &quot;&quot;;;
Exception: Sys_error &quot;: No such file or directory&quot;.
</code></pre>
<h4>抛出异常（ raise 表达式 ）</h4>
<h5>raise 异常</h5>
<h5>raise（ 异常参数 ）</h5>
<p>如果异常需要参数，则（）是必需的。</p>
<pre><code class="language-ocaml"># raise Not_found;;
Exception: Not_found.
# raise (Sys_error &quot;: No such file or directory&quot;);;
Exception: Sys_error &quot;: No such file or directory&quot;.
# raise (Sys_error &quot;: 我会抛出异常！&quot;);;
Exception: Sys_error &quot;: ?\136\145?\154?\138\155?\135??\130常?\129&quot;.
</code></pre>
<pre><code class="language-ocaml"># let rec fact n =
    if n &lt; 0 then raise (Invalid_argument &quot;: negative argument&quot;)
    else if n = 0 then 1 else n * fact (n-1);;
val fact : int -&gt; int = &lt;fun&gt;
# fact 5;;
- : int = 120
# fact (-1);;
Exception: Invalid_argument &quot;: negative argument&quot;.
</code></pre>
<h4>异常处理( try with )</h4>
<h5>try 表达式 with 异常1 -&gt; 表达式1 | ...</h5>
<pre><code class="language-ocaml"># try raise Not_found with
  | Not_found -&gt; &quot;not found !&quot;
  | _ -&gt; &quot;unknown !&quot;;;
- : string = &quot;not found !&quot;

(* 前面定义的 fact 函数例子 *)
# try fact (-1) with
  | Invalid_argument _ -&gt; 0
  | _ -&gt; 9999;;
- : int = 0
</code></pre>
<h4>异常定义</h4>
<p>异常类型的构造函数中称为异常构造函数。
该变种是 exn 类型</p>
<pre><code class="language-ocaml">(* 确认异常的变体类型 *)
# Not_found;;
- : exn = Not_found
# raise;;
- : exn -&gt; 'a = &lt;fun&gt;
</code></pre>
<p>异常定义是为exn类型添加一个新的构造函数。</p>
<p>exn类型是特殊的，你可以稍后添加一个构造函数。</p>
<h5>exception 异常名</h5>
<pre><code class="language-ocaml">(* 异常定义 *)
# exception Hoge;;
exception Hoge
# exception Fuga of string;;
exception Fuga of string
# raise Hoge;;
Exception: Hoge.
# raise (Fuga &quot;fuga!&quot;);;
Exception: Fuga &quot;fuga!&quot;.
</code></pre>
<h4>关于exn类型</h4>
<p>既然exn也是一个变体类型，它也可以作为一个参数传递。</p>
<pre><code class="language-ocaml"># exception Hoge;;
exception Hoge

(* exn 类型列表 *)
# let exnlist = [Not_found; Hoge; (Invalid_argument &quot;fuga&quot;)];;
val exnlist : exn list = [Not_found; Hoge; Invalid_argument &quot;fuga&quot;]

(* 接收exn类型的函数 *)
# let f = function
  | Hoge -&gt; &quot;hoge!&quot;
  | x -&gt; raise x;;
val f : exn -&gt; string = &lt;fun&gt;
# f Hoge;;
- : string = &quot;hoge!&quot;
# f Not_found;;
Exception: Not_found.
</code></pre>
<h3>unit 类型</h3>
<p>输出字符串的程序。</p>
<pre><code class="language-ocaml"># print_string &quot;hoge\n&quot;;;
hoge
- : unit = ()
</code></pre>
<p>返回类型是 unit 类型</p>
<p>unit 类型的值只是一个名为（）的常量，称为 unit 值。</p>
<h4>unit 类型的用法</h4>
<ul>
<li>（）上没有可以执行的操作</li>
<li>用作返回值本身没有意义的函数的返回值</li>
<li>在定义不需要有意义的参数的函数时用作参数</li>
</ul>
<pre><code class="language-ocaml"># let const () = 777;;
val const : unit -&gt; int = &lt;fun&gt;
# const ();;
- : int = 777
</code></pre>
<h5>用作判断操作是否成功的返回值</h5>
<pre><code class="language-ocaml">（*
   () 将匹配模式，如果操作成功，将返回单位类型。
   也就是说，如果匹配成功，则表示操作成功。
*）
# let () = Bytes.set &quot;Test&quot; 1 'C';;
</code></pre>
<h3>可变的数据结构</h3>
<h4>修改字符串</h4>
<h5>&quot;string&quot;.[index] &lt;- 'char'</h5>
<pre><code class="language-ocaml"># let s = &quot;life&quot;;;
val s : string = &quot;life&quot;
# s.[2] &lt;- 'v';;
- : unit = ()
# s;;
- : string = &quot;live&quot;

(* String.set 弃用 *)
# let f2 = &quot;hoge&quot;;;
val f2 : string = &quot;hoge&quot;
# Bytes.set f2 0 'H';;
- : unit = ()
# f2;;
- : string = &quot;Hoge&quot;
</code></pre>
<h5>该操作操作参考目的地</h5>
<pre><code class="language-ocaml"># let s = &quot;hoge&quot;;;
val s : string = &quot;hoge&quot;
# let a = (s, s);;
val a : string * string = (&quot;hoge&quot;, &quot;hoge&quot;)
# Bytes.set s 3 'E';;
- : unit = ()

(* 两者都被改变，因为参考目标是相同的 *)
# a;;
- : string * string = (&quot;hogE&quot;, &quot;hogE&quot;)
</code></pre>
<h4>物理相等</h4>
<h5>物理相等 =&gt; 比较数据地址时的平等性</h5>
<ul>
<li>使用 ==, !=</li>
</ul>
<h5>结构相等 =&gt; 平等作为价值进行比较</h5>
<ul>
<li>使用=，&lt;&gt;</li>
</ul>
<pre><code class="language-ocaml"># let s1 = &quot;hoge&quot; and s2 = &quot;hoge&quot;;;
val s1 : string = &quot;hoge&quot;
val s2 : string = &quot;hoge&quot;
(* 结构相等 *)
# s1 = s2;;
- : bool = true
(* 物理相等 *)
# s1 == s2;;
- : bool = false
# s1 != s2;;
- : bool = true
</code></pre>
<h4>可修改的记录</h4>
<ul>
<li>修改记录 =&gt; 使用 mutable 关键字</li>
<li>记录修改 =&gt; record.field &lt;- 值</li>
</ul>
<pre><code class="language-ocaml"># type account = {name:string;mutable amount:int};;
type account = { name : string; mutable amount : int; }
# let ac = {name = &quot;bob&quot;; amount = 1000};;
val ac : account = {name = &quot;bob&quot;; amount = 1000}
# ac.amount &lt;- 999;;
- : unit = ()
# ac;;
- : account = {name = &quot;bob&quot;; amount = 999}
(* 不可改变 *)
# let () = ac.name &lt;- &quot;Hoge&quot;;;
Error: The record field name is not mutable
(* 这样是可以的 *)
# ac.name.[0] &lt;- 'B';;
- : unit = ()
# ac;;
- : account = {name = &quot;Bob&quot;; amount = 999}
</code></pre>
<h4>创建引用（ ref ）</h4>
<ul>
<li>创建引用 =&gt; ref函数</li>
<li>引用获取 =&gt; !引用</li>
<li>引用目标重写 =&gt; 引用 := 值</li>
</ul>
<pre><code class="language-ocaml">(* 创建引用 *)
# let h = ref &quot;Hoge&quot; and f = ref &quot;Fuga&quot;;;
val h : string ref = {contents = &quot;Hoge&quot;}
val f : string ref = {contents = &quot;Fuga&quot;}

(* 引用获取 *)
# let () = print_string (!h ^ !f ^ &quot;\n&quot;);;
HogeFuga

(* 引用重写 *)
# h := !f;;
- : unit = ()
# let () = print_string (!h ^ !f ^ &quot;\n&quot;);;
FugaFuga
</code></pre>
<h4>引用的引用 ( ref ref )</h4>
<p>它也可以像C语言中的双指针一样</p>
<pre><code class="language-ocaml">(* 创建引用 *)
# let r1 = ref 5 and r2 = ref 2;;
val r1 : int ref = {contents = 5}
val r2 : int ref = {contents = 2}
(* 引用的引用创建 *)
# let rr1 = ref r1 and rr2 = ref r2;;
val rr1 : int ref ref = {contents = {contents = 5}}
val rr2 : int ref ref = {contents = {contents = 2}}
(* 引用操作 *)
# let () = !rr1 := !(!rr2);;
# (!r1, !r2);;
- : int * int = (2, 2)
</code></pre>
<h4>数组</h4>
<ul>
<li>[|值1;值2; ... |]</li>
<li>引用元素 =&gt; [| ... |].( 下标 )</li>
<li>改变数组元素 =&gt; [| ... |].( 下标 ) &lt;- value</li>
</ul>
<p>数组的长度是固定的。</p>
<p>您可以通过下标直接获取任何元素。</p>
<h3>程序控制结构</h3>
<p>作为OCaml的规范，参数的评估顺序是未定义的。</p>
<p>因此，准备了用于像过程性语言那样控制执行顺序的语法。</p>
<h4>顺序执行</h4>
<h5>表达式1; 表达式2; ... 表达式n</h5>
<p>与如下如下代码一样</p>
<pre><code class="language-ocaml">let _ = 表达式1 in
let _ = 表达式2 in
.
.
.
表达式n
</code></pre>
<p>最后的表达式n是整个返回值。</p>
<h4>begin 与 end</h4>
<p>你可以写 begin 表达式1; ...表达式n end ，而不是（表达式; ...表达式n）</p>
<p>这似乎是首选。</p>
<h4>ignore</h4>
<p>如果相当于一个句子的表达式返回非 unit 类型，则会出现警告</p>
<p>忽略警告的函数</p>
<pre><code class="language-ocaml">(* 将返回值设置为0（int） *)
# let print_hello () = print_string &quot;Hello, &quot;; 0;;
val print_hello : unit -&gt; int = &lt;fun&gt;

(* 警告出现在 print_hello *)
# print_hello (); print_string &quot;World\n&quot;;;
Warning 10: this expression should have type unit.
Hello, World
- : unit = ()

(* 忽略不发出警告 *)
# ignore (print_hello ()); print_string &quot;World\n&quot;;;
Hello, World
- : unit = ()
</code></pre>
<p>;是一个分隔符</p>
<p>;不是终止符，它被用作分隔符。</p>
<p>因此，要小心如果在表达式n的末尾添加一个分号作为表达式n，经常会出现额外的错误。</p>
<h4>条件语句</h4>
<p>if then 的 then 子句的返回值是（），则else可以省略。</p>
<p>if 表达式1 then 表达式2 =&gt; if 表达式1 then 表达式2 else（）</p>
<p>这意味着如果表达式1不成立，将会做任何事情。</p>
<h4>循环语句</h4>
<p>for 和 while 语句</p>
<h5>for</h5>
<p>for =&gt; for variable = start_value to end_value do 表达式 done</p>
<p>或</p>
<p>for variable = start_value downto end_value do 表达式 done</p>
<pre><code class="language-ocaml">(* for 循环 *)
# for i = 1 to 10 do begin print_int i; () end done;;
12345678910- : unit = ()
# for i = 10 downto 1 do begin print_int i; () end done;;
10987654321- : unit = ()
</code></pre>
<h5>while</h5>
<p>while 条件 do 表达式 done</p>
<p>while据说它用得不多。</p>
<pre><code class="language-ocaml">let quit_loop = ref false in
  while not !quit_loop do
  print_string &quot;Have you had enough yet? (y/n) &quot;;
  let str = read_line () in
  if str.[0] = 'y' then
      quit_loop := true
  done;;
Have you had enough yet? (y/n) n
Have you had enough yet? (y/n) y
- : unit = ()
</code></pre>

            </div>
        </div>
        </div>
        </div>
    </body>

</html>
