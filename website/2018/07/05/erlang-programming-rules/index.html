<!--
 * @Author: Leland
 * @Date: 2019-12-27 15:59:00
 * @Description: Description
 -->
<!doctype html>
<html>

    <head>
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui" />
        <title>编程规则和约定</title>
        <link href="/css/style.css" rel="stylesheet" />
        <meta name="description" content="编程规则和约定">
    </head>

    <body>
        <div>
        <div>
        <header class="header">
            <div class="container header-wrap">
                <h1 class="site-name">
                    <a href="/">
                        首页
                    </a>
                </h1>
                <ul class="nav">
                    {{navs}}
                </ul>
            </div>
        </header>
        </div>
        <div class="container main">
        <div class="page-body">
            <div class="markdown-body">
                <h1>编程规则和约定</h1>
<p>译自：http://www.erlang.se/doc/programming_rules.shtml</p>
<h2>使用 Erlang 进行程序开发 - 编程规则和约定</h2>
<h3>抽象</h3>
<blockquote>
<p>这是对编程规则的描述，并建议如何使用 Erlang 编写系统。</p>
</blockquote>
<p>注意：本文档是初步文档，不完整。</p>
<h4>这里没有记录使用EBC“基础系统”的要求，但如果要使用“基础系统”，必须在非常早期的设计阶段遵循。这些要求记录在1/10268-AND 10406 Uen“MAP - 启动和错误恢复”中。</h4>
<h3>1、目的</h3>
<p>本文列出了在使用 Erlang 指定和编程软件系统时应该考虑的一些方面。它并不试图给出与 Erlang 使用无关的一般规范和设计活动的完整描述。</p>
<h3>2、结构和 Erlang 术语</h3>
<p>Erlang 系统分为<em>模块</em>。模块由<em>函数</em>和<em>属性</em>组成。函数要么只在模块内可见，要么被<em>导出</em>，即它们也可以被其他模块中的其他函数调用。属性以“ - ”开头，并放在模块的开头。</p>
<p>使用 Erlang 设计的系统中的工作是由<em>进程</em>完成的。进程是一个可以在许多模块中使用函数的工作。进程通过发送消息相互通信。进程接收发送给它们的消息，进程可以决定它准备接收哪些消息。其他消息排队，直到接收进程准备接收它们。</p>
<p>进程可以通过建立到它的链接来监督另一个进程的存在。当进程终止时，它会自动将退出信号发送到与其链接的进程。接收退出信号的进程的默认行为是终止并将信号传播到其链接进程。进程可以通过捕获出口来更改此默认行为，这会导致发送到进程的所有退出信号变为消息。</p>
<p>纯函数是一个函数，它在给定相同参数的情况下返回相同的值，而不管函数调用的上下文如何。这是我们通常对数学函数的期望。也就是说不纯的功能有副作用。</p>
<p>如果函数 a）发送消息 b）接收消息 c）调用 exit d）调用任何改变进程环境或操作模式的 BIF，通常会出现副作用（例如 get/1，put/2，erase/1，process_flag/2 等）。</p>
<p><em>警告</em>：本文档包含错误代码的示例。</p>
<h3>3、SW 工程原理</h3>
<h4>3.1 从模块导出尽可能少的函数</h4>
<p>模块是 Erlang 中的基本代码结构实体。模块可以包含大量函数，但只能从模块外部调用模块导出列表中包含的函数。</p>
<p>从外部看，模块的复杂性取决于从模块导出的函数的数量。导出一个或两个函数的模块通常比导出许多函数的模块更容易理解。</p>
<p>导出/非导出函数的比率较低的模块是可取的，因为模块的用户只需要了解从模块导出的函数的功能。</p>
<p>此外，如果外部接口保持不变，模块中代码的编写者或维护者可以以任何适当的方式改变模块的内部结构。</p>
<h4>3.2 尝试减少模块间依赖性</h4>
<p>与仅在几个不同模块中调用函数的模块相比，在许多不同模块中调用函数的模块将更难以维护。</p>
<p>这是因为每次我们对模块接口进行更改时，我们都必须检查代码中调用此模块的所有位置。减少模块之间的相互依赖性简化了维护这些模块的问题。</p>
<p>我们可以通过减少从给定模块调用的不同模块的数量来简化系统结构。</p>
<p>还要注意，期望模块间调用依赖性形成树而不是循环图。例：
<img src="/images/module-dep-ok.gif" alt="好" /></p>
<p>但不是</p>
<p><img src="/images/module-dep-bad.gif" alt="坏" /></p>
<h4>3.3 将常用代码放入库中</h4>
<p>应将常用代码放入库中。库应该是相关函数的集合。应该尽力确保库包含相同类型的函数。因此，诸如仅包含用于操纵列表的函数的列表的库是一个不错的选择，而包含用于操纵列表和用于数学的函数的组合的库，lists_and_maths 是非常糟糕的选择。</p>
<p>最好的库函数没有副作用。具有副作用函数的库限制了可重用性。</p>
<h4>3.4 将“棘手”或“脏”代码隔离到单独的模块中</h4>
<p>通常可以通过使用干净和脏代码的混合来解决问题。将干净和脏的代码分成单独的模块。</p>
<p>脏代码是做坏事的代码。例：</p>
<ul>
<li>使用进程字典。</li>
<li>使用 erlang:process_info/1 用于奇怪的目的。</li>
</ul>
<p>专注于尝试最大化干净代码的数量，并尽量减少脏代码的数量。隔离脏代码并清楚地评论或以其他方式记录与此部分代码相关的所有副作用和问题。</p>
<h4>3.5 不要假设调用者将对函数的结果做什么</h4>
<p>不要假设函数被调用的原因或者函数的调用者希望对结果做什么。</p>
<p>例如，假设我们使用某些可能无效的参数调用例程。例程的实现者不应该在参数无效时对函数的调用者希望发生什么做出任何假设。</p>
<p>因此我们不应该写这样的代码</p>
<pre><code class="language-erlang">do_something(Args) -&gt;
    case check_args(Args) of
        ok -&gt; 
            {ok, do_it(Args)};
        {error, What} -&gt;
            String = format_the_error(What),
            io:format(&quot;* error:~s\n&quot;, [String]), %% 不要这样做
            error
    end.
</code></pre>
<p>而是这样写：</p>
<pre><code class="language-erlang">do_something(Args) -&gt;
    case check_args(Args) of
        ok -&gt; 
            {ok, do_it(Args)};
        {error, What} -&gt;
            {error, What}
    end.

error_report({error, What}) -&gt;
    format_the_error(What).
</code></pre>
<p>在前一种情况下，错误字符串始终打印在标准输出上，在后一种情况下，错误描述符将返回给应用程序。应用程序现在可以决定如何处理此错误描述符。</p>
<p>通过调用 error_report/1，应用程序可以将错误描述符转换为可打印的字符串，并在需要时将其打印出来。但这可能不是理想的行为 - 在任何情况下，决定如何处理结果都留给调用者。</p>
<h4>3.6 抽象出代码或行为的常见模式</h4>
<p>每当在代码中的两个或多个位置具有相同的代码模式时，尝试将其与公共函数隔离并调用此函数，而不是将代码放在两个不同的位置。复制的代码需要很多维护。</p>
<p>如果您在代码中的两个或多个位置看到类似的代码模式（即几乎相同），则值得花一些时间来查看是否有人不能稍微改变问题以使不同的情况相同，然后写入少量额外的 代码来描述两者之间的差异。</p>
<p>避免“复制”和“粘贴”编程，使用函数！</p>
<h4>3.7 自顶向下</h4>
<p>使用自上而下的方式编写程序，而不是自下而上（从详细信息开始）。自上而下是一种不断接近实现细节的好方法，最终定义了原始函数。代码将独立于表示，因为在设计更高级别的代码时不知道表示。</p>
<h4>3.8 不要优化代码</h4>
<p>不要在第一阶段优化代码。首先让它正确，然后(如果必要)让它快速(同时保持正确)。</p>
<h4>3.9 使用“最小惊讶”原则</h4>
<p>系统应始终以对用户造成“最小惊讶”的方式作出响应 - 即，用户应该能够预测当他们做某事时会发生什么并且不会对结果感到惊讶。</p>
<p>这与一致性有关，这是一个一致的系统，其中不同的模块以类似的方式执行操作比每个模块以不同方式执行操作的系统更容易理解。</p>
<p>如果你对函数的作用感到惊讶，你的函数可以解决错误的问题，也可能名字错误。</p>
<h4>3.10 尽量消除副作用</h4>
<p>Erlang 有几个具有副作用的原语。使用它们的函数不能轻易地重复使用，因为它们会导致对环境的永久性更改，并且在调用此类例程之前必须知道进程的确切状态。</p>
<p>使用无副作用的代码尽可能多地编写代码。</p>
<p>最大化纯函数的数量。</p>
<p>收集具有副作用的功能并清楚地记录所有副作用。</p>
<p>有点小心，大多数代码都可以以无副作用的方式编写 - 这将使系统更易于维护，测试和理解。</p>
<h4>3.11 不允许私有数据结构“泄漏”出模块</h4>
<p>最好通过一个简单的例子来说明这一点。我们定义了一个名为 queue 的简单模块 - 来实现队列：</p>
<pre><code class="language-erlang">-module(queue).
-export([add/2, fetch/1]).

add(Item, Q) -&gt;
    lists:append(Q, [Item]).

fetch(H|T) -&gt;
    {ok, H, T};
fetch([]) -&gt; 
    empty.
</code></pre>
<p>这将队列作为列表实现，遗憾的是，用户必须知道该队列被表示为列表。使用它的典型程序可能包含以下代码片段：</p>
<pre><code class="language-erlang">NewQ = [], % 不要这样做
Queue1 = queue:add(joe, NewQ), 
Queue2 = queue:add(mike, Queue1), ....
</code></pre>
<p>这很糟糕 - 因为用户a）需要知道队列被表示为列表而b）实现者不能改变队列的内部表示（他们可能希望稍后这样做以提供更好的模块版本） 。</p>
<p>更好的是：</p>
<pre><code class="language-erlang">-module(queue).
-export([new/0, add/2, fetch/1]).

new() -&gt;
    [].

add(Item, Q) -&gt;
    lists:append(Q, [Item]).

fetch([H|T]) -&gt;
    {ok, H, T};
fetch([]) -&gt;
    empty.
</code></pre>
<p>现在我们可以写：</p>
<pre><code class="language-erlang">NewQ = queue:new(), 
Queue1 = queue:add(joe, NewQ), 
Queue2 = queue:add(mike, Queue1), ...
</code></pre>
<p>哪个更好，并纠正这个问题。现在假设用户需要知道队列的长度，他们可能会想写：</p>
<pre><code class="language-erlang">Len = length(Queue) % 不要这样做
</code></pre>
<p>因为他们知道队列被表示为列表。再次，这是糟糕的编程实践，导致代码很难维护和理解。如果需要知道队列的长度，则必须将长度函数添加到模块中，因此：</p>
<pre><code class="language-erlang">-module(queue).
-export([new/0, add/2, fetch/1, len/1]).

new() -&gt; [].

add(Item, Q) -&gt;
    lists:append(Q, [Item]).

fetch([H|T]) -&gt;
    {ok, H, T};

fetch([]) -&gt;
    empty.

len(Q) -&gt;
    length(Q).
</code></pre>
<p>现在用户可以调用 queue:len(Queue) 代替。</p>
<p>这里我们说我们“抽象出”队列的所有细节（队列实际上是所谓的“抽象数据类型”）。</p>
<p>为什么我们会遇到这些麻烦？ - 抽象出实现的内部细节的做法允许我们改变实现而不改变调用我们已经改变的模块中的函数的模块的代码。因此，例如，更好的队列实现如下：</p>
<pre><code class="language-erlang">-module(queue).
-export([new/0, add/2, fetch/1, len/1]).

new() -&gt;
    {[], []}.

add(Item, {X, Y}) -&gt; % 更快地添加元素
    {[Item|X], Y}.

fetch({X, [H|T]}) -&gt;
    {ok, H, {X, Y}}.

fetch({[], []}) -&gt;
    empty;

fetch({X, []}) -&gt;
    % 有时只执行这个繁重的计算。
    fetch({[], lists:reverse(X)}).

len({X, Y}) -&gt;
    length(X) + length(Y).
</code></pre>
<h4>3.12 使代码尽可能具有确定性</h4>
<p>无论程序运行多少次，确定性程序总是以相同的方式运行。非确定性程序可能在每次运行时提供不同的结果。出于调试目的，最好使事物尽可能确定。这有助于使错误重现。</p>
<p>例如，假设一个进程必须启动五个并行进程，然后检查它们是否已正确启动，进一步假设启动这五个进程的顺序无关紧要。</p>
<p>然后，我们可以选择并行启动所有五个，然后检查它们是否已正确启动，但最好一次启动一个并检查每个启动是否正确，然后再启动下一个。</p>
<h4>3.13 不要“防守”编程</h4>
<p>防御性程序是程序员不“信任”输入数据到他们正在编程的系统部分的程序。通常，不应将输入数据测试到函数的正确性。系统中的大多数代码都应该假设所讨论的函数的输入数据是正确的。只有一小部分代码应该实际执行任何数据检查。这通常是在数据第一次“进入”系统时完成的，一旦检查了数据，因为它进入系统后应该假定它是正确的。</p>
<p>例：</p>
<pre><code class="language-erlang">%% Args: Option is all|normal
get_server_usage_info(Option, AsciiPid) -&gt;
    Pid = list_to_pid(AsciiPid),
    case Option of
        all -&gt; get_all_info(Pid);
        normal -&gt; get_normal_info(Pid)
    end.
</code></pre>
<p>如果 Option 既不正常也不是全部，该函数将崩溃，它应该这样做。呼叫者负责提供正确的输入。</p>
<h4>3.14 使用设备驱动程序隔离硬件接口</h4>
<p>应通过使用设备驱动程序将硬件与系统隔离。设备驱动程序应该实现硬件接口，使硬件看起来像是 Erlang 进程。应该使硬件看起来和行为像普通的 Erlang 进程一样。硬件应该看起来接收和发送正常的 Erlang 消息，并且应该在发生错误时以传统方式响应。</p>
<h4>3.15 在同一个函数中执行和撤消操作</h4>
<p>假设我们有一个程序打开一个文件，用它做一些事情并稍后关闭它。这应编码为：</p>
<pre><code class="language-erlang">do_something_with(File) -&gt;
    case file:open(File, read) of,
        {ok, Stream} -&gt;
            doit(Stream),
            file:close(Stream) % The correct solution
        Error -&gt; Error
    end.
</code></pre>
<p>请注意在同一例程中打开文件（file:open）和关闭文件（file:close）的对称性。下面的解决方案更难以遵循，并且关闭哪个文件并不明显。不要这样编程：</p>
<pre><code class="language-erlang">do_something_with(File) -&gt; 
  case file:open(File, read) of, 
    {ok, Stream} -&gt;
      doit(Stream)
    Error -&gt; Error
  end.

doit(Stream) -&gt; 
  ...., 
  func234(...,Stream,...).
  ...

func234(..., Stream, ...) -&gt;
  ...,
  file:close(Stream) %% 不要这样做
</code></pre>
<h3>4、错误处理</h3>
<h4>4.1 单独的错误处理和正常的案例代码</h4>
<p>不要使用设计用于处理异常的代码来填充“正常情况”的代码。你应该尽可能只编程正常情况。如果正常情况的代码失败，您的进程应该报告错误并尽快崩溃。不要尝试修复错误并继续。应该在不同的过程中处理错误（参见第15页的“每个过程应该只有一个”角色“）</p>
<p>清除错误恢复代码和正常案例代码应大大简化整个系统设计。</p>
<p>检测到软件或硬件错误时生成的错误日志将在稍后阶段用于诊断和更正错误。应保留对此过程有帮助的任何信息的永久记录。</p>
<h4>4.2 识别错误内核</h4>
<p>系统设计的基本要素之一是确定系统的哪个部分必须是正确的，以及系统的哪个部分不必是正确的。</p>
<p>在传统的操作系统设计中，假定系统的内核是并且必须是正确的，而所有用户应用程序不一定必须是正确的。如果用户应用程序失败，则仅涉及发生故障的应用程序，但不应影响整个系统的完整性。</p>
<p>系统设计的第一部分必须是识别必须正确的系统部分;我们称之为错误内核。错误内核通常具有某种实时内存驻留数据库，用于存储硬件状态。</p>
<h3>5、进程，服务器和消息</h3>
<h4>5.1 在一个模块中实现进程</h4>
<p>实现单个进程的代码应包含在一个模块中。进程可以调用任何库例程中的函数，但进程的“顶部循环”的代码应该包含在单个模块中。进程顶部循环的代码不应分成几个模块 - 这将使控制流程极难理解。这并不意味着不应该使用通用服务器库，这些库用于帮助构建控制流。</p>
<p>相反，应该在单个模块中实现不超过一种进程的代码。包含几个不同过程的代码的模块可能非常难以理解。应将每个单独流程的代码分解为单独的模块。</p>
<h4>5.2 使用进程来构建系统</h4>
<p>进程是基本的系统结构元素。但是，当可以使用函数调用时，不要使用进程和消息传递。</p>
<h4>5.3 注册进程</h4>
<p>注册的进程应使用与模块相同的名称进行注册。这样可以轻松找到进程的代码。只注册应该存在很长时间的进程。</p>
<h4>5.4 为系统中的每个真正并发活动分配一个并行进程</h4>
<p>在决定是否使用顺序或并行进程实现事物时，应该使用问题的内在结构所隐含的结构。主要规则是： “使用一个并行进程来模拟现实世界中每个真正的并发活动”</p>
<p>如果并行进程的数量与现实世界中真正并行活动的数量之间存在一对一的映射，则程序将易于理解。</p>
<h4>5.5 每个进程应该只有一个“角色”</h4>
<p>进程可以在系统中具有不同的角色，例如在客户端 - 服务器模型中。</p>
<p>进程应该尽可能只有一个角色，即它可以是客户端或服务器但不应该组合这些角色。</p>
<p>进程可能具有的其他角色是：</p>
<ul>
<li>主管：监视其他进程并在失败时重新启动它们。</li>
<li>工人：正常的工作进程（可能有错误）。</li>
<li>值得信赖的工人：不允许有错误。</li>
</ul>
<h4>5.6 尽可能使用服务器和协议处理程序的通用函数</h4>
<p>在许多情况下，最好使用通用服务器程序，例如标准库中实现的 generic 服务器。一致使用一小组通用服务器将大大简化整个系统结构。</p>
<p>对于系统中的大多数协议处理软件也是如此。</p>
<h4>5.7 标记消息</h4>
<p>应标记所有消息。这使得 receive 语句中的顺序不那么重要，并且新消息的实现更容易。</p>
<p>不要像这样编程：</p>
<pre><code class="language-erlang">loop(State) -&gt;
    receive
        ...
        {Mod, Funcs, Args} -&gt; % 不要这样做
            apply(Mod, Funcs, Args),
            loop(State);
        ...
    end.
</code></pre>
<p>如果将新消息 {get_status_info, From, Option} 置于 {Mod, Func, Args} 消息下方，则会引发冲突。</p>
<p>如果消息是同步的，则返回消息应使用新原子标记，描述返回的消息。示例：如果传入消息标记为 get_status_info，则返回的消息可以标记为 status_info。选择不同标签的一个原因是使调试更容易。</p>
<p>这是一个很好的解决方案：</p>
<pre><code class="language-erlang">loop(State) -&gt;
    receive
        ...
        {execute, Mod, Funcs, Args} -&gt; % 使用标记的消息。
            apply(Mod, Funcs, Args),
            loop(State);
        {get_status_info, From, Option} -&gt;
            From ! {status_info, get_status_info(Option, State)},
            loop(State);
        ...
    end.
</code></pre>
<h4>5.8 刷新未知消息</h4>
<p>每个服务器在至少一个 receive 语句中应该有一个 Other 选项。这是为了避免填充消息队列。例：</p>
<pre><code class="language-erlang">main_loop() -&gt;
    receive
        {msg1, Msg1} -&gt;
            ...,
            main_loop();
        {msg2, Msg2} -&gt;
            ...
            main_loop();
        Other -&gt; %刷新消息队列。
            error_logger:error_msg(
                &quot;Error: Process ~w got unknown msg ~w~n.&quot;,
                [self(), Other]),
            main_loop()
    end.
</code></pre>
<h4>5.9 编写尾递归服务器</h4>
<p>所有服务器必须是尾递归的，否则服务器将占用内存，直到系统用完为止。</p>
<p>不要像这样编程：</p>
<pre><code class="language-erlang">loop() -&gt;
    receive
        {msg1, Msg1} -&gt;
            ...,
            loop();
        stop -&gt;
            true;
        Other -&gt;
            error_logger:log({error, {process_got_other, self(), Other}}),
            loop
    end,
    io:format(&quot;Server going down&quot;). % 不要这样做！
                    % 这不是尾递归
</code></pre>
<p>这是一个正确的解决方案：</p>
<pre><code class="language-erlang">loop() -&gt;
    receive
        {msg1, Msg1} -&gt;
            ...
            loop();
        stop -&gt;
            io:format(&quot;Server going down&quot;);
        Other -&gt;
            error_logger:log({error, {process_got_other, self(), Other}}),
            loop()
    end. % 这是尾递归
</code></pre>
<p>如果您使用某种服务器库，例如 generic ，则会自动避免出现此错误。</p>
<h4>5.10 接口函数</h4>
<p>尽可能使用接口函数，避免直接发送消息。封装传递到接口函数的消息。有些情况下你不能这样做。</p>
<p>消息协议是内部信息，应该隐藏到其他模块。</p>
<p>接口函数示例：</p>
<pre><code class="language-erlang">-module(fileserver).
-export([start/0, stop/0, open_file/1, ...]).

open_file(FileName) -&gt;
    fileserver ! {open_file_request, FileName},
    receive
        {open_file_response, Result} -&gt; Result
    end.

...&lt;code&gt;...
</code></pre>
<h4>5.11 超时</h4>
<p>在 receive 语句中使用 after 要小心。确保在以后收到消息时处理该情况（请参见第 16 页的“刷新未知消息”）。</p>
<h4>5.12 陷阱退出</h4>
<p>尽可能少的进程应该捕获退出信号。进程要么退出，要么不退出。对于进程来说，“切换”捕获出口通常是非常糟糕的做法。</p>
<h3>6、各种 Erlang 特定约定</h3>
<h4>6.1 使用记录作为主要数据结构</h4>
<p>使用记录作为主要数据结构。记录是标记的元组，并在 Erlang 版本 4.3 及其后引入（参见 EPK/NP 95:034）。它类似于 C 中的 struct 或 Pascal 中的 record。如果要在多个模块中使用该记录，则应将其定义放在模块中包含的头文件（带后缀.hrl）中。如果记录仅在一个模块中使用，则记录的定义应位于定义模块的文件的开头。</p>
<p>Erlang 的记录功能可用于确保数据结构的跨模块一致性，因此在模块之间传递数据结构时应由接口函数使用。</p>
<h4>6.2 使用选择器和构造函数</h4>
<p>使用记录功能提供的选择器和构造函数来管理记录实例。不要使用明确假设记录是元组的匹配。例：</p>
<pre><code class="language-erlang">demo() -&gt;
    P = #person{name = &quot;Joe&quot;, age = 29},
    #person{name = Name1} = P, % 使用匹配，或......
    Name2 = P#person.name. % 像这样使用选择器。
</code></pre>
<p>不要像这样编程：</p>
<pre><code class="language-erlang">demo() -&gt;
    P = #person{name = &quot;Joe&quot;, age = 29},
    {person, Name, _Age, _Phone, _Misc} = P. % 不要这样做
</code></pre>
<h4>6.3 使用标记的返回值</h4>
<p>使用标记的返回值。</p>
<p>不要像这样编程：</p>
<pre><code class="language-erlang">keysearch(Key, [{Key, Value}|_Tail]) -&gt;
    Value; %% 不要返回未标记的值！
keysearch(Key, [{_WrongKey, _WrongValue} | Tail]) -&gt;
    keysearch(Key, Tail);
Keysearch(Key, []) -&gt;
    false.
</code></pre>
<p>然后 {Key, Value} 不能包含 false 值。这是正确的解决方案：</p>
<pre><code class="language-erlang">keysearch(Key, [{Key, Value} | _Tail]) -&gt;
    {value, Value}; %% 正确。返回标记值。
keysearch(Key, [{_WrongKey, _WrongValue}, | Tail]) -&gt;
    keysearch(Key, Tail);
keysearch(Key, []) -&gt;
    false.
</code></pre>
<h4>6.4 小心使用捕获和抛异常</h4>
<p>除非你确切知道自己在做什么，否则不要使用 catch 和 throw！使用 catch 和 throw 尽可能少。</p>
<p>当程序处理复杂且不可靠的输入（来自外部世界，而不是来自您自己的可靠程序）时，catch 和 throw 可能很有用，这可能会导致代码中很多地方出现错误。一个例子是编译器。</p>
<h4>6.5 小心使用进程字典</h4>
<p>不要使用 get 和 put 等。除非你确切知道你在做什么！尽可能少地使用 get 和 put 等。</p>
<p>可以通过引入新参数来重写使用进程字典的函数。</p>
<p>例： 不要像这样编程：</p>
<pre><code class="language-erlang">tokenize([H|T]) -&gt;
    ...
tokenize([]) -&gt;
    case get_characters_from_device(get(device)) of % 不要使用 get/1！
        eof -&gt; [];
        {value, Chars} -&gt;
            tokenize(Chars)
    end.
</code></pre>
<p>正确的解决方案：</p>
<pre><code class="language-erlang">tokenize(_Device, [H|T]) -&gt;
    ...;
tokenize(Device, []) -&gt;
    case get_characters_from_device(Device) of % 这个更好
        eof -&gt; [];
        {value, Chars} -&gt;
            tokenize(Device, Chars)
    end.
</code></pre>
<p>他使用 get 和 put 会导致函数在不同的场合使用相同的输入调用时表现不同。这使得代码难以阅读，因为它是非确定性的。调试将更复杂，因为使用 get 和 put 的函数不仅是其参数的函数，还是进程字典的函数。Erlang 中的许多运行时错误（例如 bad_match ）包含函数的参数，但不包括进程字典。</p>
<h4>6.6、不要使用导入</h4>
<p>不要使用 -import，使用它会使代码更难阅读，因为您无法直接查看函数定义的模块。使用 exref（交叉引用工具）查找模块依赖项。</p>
<h4>6.7 导出函数</h4>
<p>区分函数的导出原因。可以导出函数，原因如下（例如）：</p>
<ul>
<li>它是模块的用户界面。</li>
<li>它是其他模块的接口函数。</li>
<li>它从 apply，spawn 等调用，但仅在其模块中调用。</li>
</ul>
<p>使用不同的 -export 分组并相应地注释它们。例：</p>
<pre><code class="language-erlang">%% 用户界面
-export([help/0, start/0, stop/0, info/1]).

%% 模块间导入
-export([make_pid/1, make_pid/3]).
-export([process_abbrevs/0, print_info/5]).

%% 导出仅在模块内使用
-export([init/1, info_log_impl/1]).
</code></pre>
<h3>7、具体的词汇和风格的约定。</h3>
<h4>7.1 不要编写深层嵌套代码</h4>
<p>嵌套代码是包含其他case / if / receive语句中的case / if / receive语句的代码。编写深层嵌套代码是一种糟糕的编程风格 - 代码倾向于在页面中向右移动并很快变得不可读。尝试将大多数代码限制为最多两个缩进级别。这可以通过将代码分成更短的函数来实现。</p>
<h4>7.2 不要写非常大的模块</h4>
<p>模块不应包含超过 400 行的源代码。最好分成几个小模块而不是一个大模块。</p>
<h4>7.3 不要写很长的函数</h4>
<p>不要编写超过 15 到 20 行代码的函数。将大函数分成几个较小的函数。不要通过写长行来解决问题。</p>
<h4>7.4 不要写很长的行</h4>
<p>不要写很长的行。一行不应超过 80 个字符。 （例如，它将适合A4页面。）</p>
<p>在 Erlang 4.3 及其后，字符串常量将自动连接。例：</p>
<pre><code class="language-erlang">io:format(&quot;Name: ~s, Age: ~w,Phone: ~w ~n&quot;
        &quot;Dictionary: ~w.~n&quot;, [Name, Age, Phone, Dict])
</code></pre>
<h4>7.5 变量名称</h4>
<p>选择有意义的变量名称 - 这非常困难。</p>
<p>如果变量名称由多个单词组成，请使用“_”或大写字母将它们分开。例如：My_variable 或 MyVariable。</p>
<p>避免使用“<em>” 作为无关变量，使用以 “</em>”开头的变量。例如：_Name。如果您在稍后阶段需要变量的值，则只需删除前导下划线。您将无法找到替换下划线的问题，并且代码将更易于阅读。</p>
<h4>7.6 函数名称</h4>
<p>函数名称必须与函数的名称完全一致。它应该返回函数名隐含的参数类型。它不应该让读者感到惊讶。使用传统函数的常规名称（start，stop，init，main_loop）。</p>
<p>解决相同问题的不同模块中的函数应具有相同的名称。例如：Module:module_info()。</p>
<p>错误的函数名称是最常见的编程错误之一 - 很好的选择名称是非常困难的！</p>
<p>在编写许多不同的函数时，某种命名约定非常有用。例如，名称前缀“is_”可用于表示所讨论的函数返回原子 true 或 false</p>
<pre><code class="language-erlang">if_...() -&gt; true | false
check_...() -&gt; {ok, ...} || {error, ...}
</code></pre>
<h4>7.7 模块名称</h4>
<p>Erlang 具有扁平模块结构（即模块内没有模块）。但是，我们通常希望模拟分层模块结构的效果。这可以通过具有相同模块前缀的多组相关模块来完成。</p>
<p>例如，如果使用五个不同且相关的模块实现ISDN处理程序。这些模块的名称应如下：</p>
<pre><code class="language-erlang">isdn_init
isdn_partb
isdn_...
</code></pre>
<h4>7.8 以一致的方式格式化程序</h4>
<p>一致的编程风格将帮助您和其他人理解您的代码。不同的人在缩进，使用空间等方面有不同的风格。例如，您可能希望在元素之间使用单个逗号编写元组：</p>
<pre><code class="language-erlang">{12,23,45}
</code></pre>
<p>其他人可能会使用逗号后跟空格：</p>
<pre><code class="language-erlang">{12, 23, 45}
</code></pre>
<p>一旦你采用了风格 - 坚持下去。</p>
<p>在较大的项目中，应在所有部分使用相同的样式。</p>
<h3>8、文档化代码</h3>
<h4>8.1 属性代码</h4>
<p>您必须始终正确地归因于模块标头中的所有代码。说出所有有关该模块的想法来自哪里 - 如果您的代码是从其他代码派生出来的，那么说明您从哪里获得此代码以及谁编写代码。</p>
<p>永远不要窃取代码 - 窃取代码是从其他模块编辑代码并忘记说谁编写原始代码。</p>
<p>有用属性的示例如下：</p>
<pre><code class="language-erlang">-revision('Revision: 1.14 ').
-created('Date: 1995/01/01 11:21:11 ').
-created_by('eklas@erlang').
-modified('Date: 1995/01/05 13:04:07 ').
-modified_by('mbj@erlang').
</code></pre>
<h4>8.2 在代码中提供参考规范</h4>
<p>在代码中提供与理解代码相关的任何文档的交叉引用。例如，如果代码实现某些通信协议或硬件接口，则将文档和页码的精确引用提供给用于编写代码的文档。</p>
<h4>8.3 记录所有错误</h4>
<p>所有错误都应与单独文档中的含义的英文说明一起列出（请参阅第32页的“错误消息”。）</p>
<p>错误是指系统检测到的错误。</p>
<p>在程序中检测到逻辑错误的位置调用错误记录器：</p>
<pre><code class="language-erlang">error_logger:error_msg(Format, {Descriptor, Arg1, Arg2, ....})
</code></pre>
<p>并确保将 {Descriptor, Arg1, ...} 行添加到错误消息文档中。</p>
<h4>8.4 记录消息中的所有主要数据结构</h4>
<p>在系统的不同部分之间发送消息时，使用标记的元组作为主要数据结构。</p>
<p>Erlang 的记录功能（在 Erlang 版本 4.3 s及其后版本中引入）可用于确保数据结构的跨模块一致性。</p>
<p>应记录所有这些数据结构的英文描述（参见第32页的“消息描述”）。</p>
<h4>8.5 注释</h4>
<p>注释应清晰简洁，避免不必要的冗长。确保注释与代码保持同步。检查注释是否增加了对代码的理解。注释应以英文撰写。</p>
<p>关于模块的注释应该没有缩进，并以三个百分比的字符（%%%）开头，（参见第29页的“文件头，描述”）。</p>
<p>关于函数的注释应该没有缩进，并以两个百分比字符（%%）开头，（参见第27页的“注释每个函数”）。</p>
<p>Erlang 代码中的注释应以一个百分比字符（%）开头。如果一行只包含注释，则它应缩进为 Erlang 代码。这种评论应放在它所引用的陈述之上。如果注释可以与语句放在同一行，则首选。</p>
<pre><code class="language-erlang">%% Comment about function
some_useful_functions(UsefulArgugument) -&gt;
  another_functions(UsefulArgugument),    % Comment at end of line
  % Comment about complicated_stmnt at the same level of indentation
  complicated_stmnt,
......
</code></pre>
<h4>8.6、注释每个函数</h4>
<p>要记录的重要事项是：</p>
<ul>
<li>函数的目的。</li>
<li>函数的有效输入域。也就是说，函数参数的数据结构及其含义。</li>
<li>函数输出的域。也就是说，返回值的所有可能数据结构及其含义。</li>
<li>如果函数实现了复杂的算法，请对其进行描述。</li>
<li>可能由exit / 1，throw / 1或任何非明显的运行时错误产生的故障和退出信号的可能原因。注意失败和返回错误之间的区别。</li>
<li>函数的任何副作用。</li>
</ul>
<p>例如：</p>
<pre><code class="language-erlang">%%----------------------------------------------------------------------
%% 函数: get_server_statistics/2
%% 目的: 从进程中获取各种信息.
%% 参数:   Option is normal|all.
%% 返回: 列表 {Key, Value} 
%%     or {error, Reason} (如果进程死掉)
%%----------------------------------------------------------------------
get_server_statistics(Option, Pid) when pid(Pid) -&gt;
</code></pre>
<h4>8.7 数据结构</h4>
<p>记录应与计划文本描述一起定义。例：</p>
<pre><code class="language-erlang">%% File: my_data_structures.h

%%---------------------------------------------------------------------
%% Data Type: person
%% where:
%%    name: A string (default is undefined).
%%    age: An integer (default is undefined).
%%    phone: A list of integers (default is []).
%%    dict:     A dictionary containing various information about the person. 
%%       A {Key, Value} list (default is the empty list).
%%----------------------------------------------------------------------
-record(person, {name, age, phone = [], dict = []}).
</code></pre>
<h4>8.8 文件头，版权所有</h4>
<p>每个源代码文件必须以版权信息开头，例如：</p>
<pre><code class="language-erlang">%%%--------------------------------------------------------------------- 
%%% Copyright Ericsson Telecom AB 1996
%%%
%%% All rights reserved. No part of this computer programs(s) may be 
%%% used, reproduced,stored in any retrieval system, or transmitted,
%%% in any form or by any means, electronic, mechanical, photocopying,
%%% recording, or otherwise without prior written permission of 
%%% Ericsson Telecom AB.
%%%--------------------------------------------------------------------- 
</code></pre>
<h4>8.9 文件头，修订历史</h4>
<p>每个源代码文件都必须记录其修订历史记录，该历史记录显示了谁在处理文件以及他们对文件做了什么。</p>
<pre><code class="language-erlang">%%%--------------------------------------------------------------------- 
%%% Revision History
%%%--------------------------------------------------------------------- 
%%% Rev PA1 Date 960230 Author Fred Bloggs (ETXXXXX)
%%% Intitial pre release. Functions for adding and deleting foobars
%%% are incomplete
%%%--------------------------------------------------------------------- 
%%% Rev A Date 960230 Author Johanna Johansson (ETXYYY)
%%% Added functions for adding and deleting foobars and changed 
%%% data structures of foobars to allow for the needs of the Baz
%%% signalling system
%%%--------------------------------------------------------------------- 
</code></pre>
<h4>8.10 文件头，描述</h4>
<p>每个文件必须以文件中包含的模块的简短描述和所有导出函数的简要描述开头。</p>
<pre><code class="language-erlang">%%%--------------------------------------------------------------------- 
%%% Description module foobar_data_manipulation
%%%--------------------------------------------------------------------- 
%%% Foobars are the basic elements in the Baz signalling system. The
%%% functions below are for manipulating that data of foobars and for
%%% etc etc etc
%%%--------------------------------------------------------------------- 
%%% Exports
%%%--------------------------------------------------------------------- 
%%% create_foobar(Parent, Type)
%%%   returns a new foobar object
%%%   etc etc etc
%%%--------------------------------------------------------------------- 
</code></pre>
<p><em>如果您知道任何弱点，错误，经过严格测试的函数，请在特别注释中记下它们，不要试图隐藏它们。如果模块的任何部分不完整，请添加特殊注释。</em> 添加有关对模块的未来维护者有帮助的任何内容的注释。如果您正在编写的模块的产品是成功的，那么在未来可能永远不会见到的人的十年内，它仍然可能会被更改和改进。</p>
<h4>8.11 不要注释掉旧代码 - 删除它</h4>
<p>在修订历史记录中添加注释。请记住，源代码控制系统将帮助您！</p>
<h4>8.12 使用源代码控制系统</h4>
<p>所有非平凡项目都必须使用源代码控制系统（如 RCS，CVS 或 Clearcase）来跟踪所有模块。</p>
<h3>9、最常见的错误：</h3>
<ul>
<li>编写跨越多页的函数（请参阅第23页的“不要写很长的功能”）。</li>
<li>使用深度嵌套的if、receive、case 等编写函数（请参见第23页的“不要编写深层嵌套代码”）。</li>
<li>编写输入错误的函数（请参见第19页的“使用标记的返回值”）。</li>
<li>函数名称不能反映函数的作用（参见第24页的“函数s名称”）。</li>
<li>无意义的变量名称（请参见第23页的“变量名称”）。</li>
<li>在不需要时处理进程（请参阅第14页的“为系统中的每个真正并发活动分配一个并行进程”）。</li>
<li>选择错误的数据结构（错误表示）。</li>
<li>糟糕的注释或根本没有注释（总是记录参数和返回值）。</li>
<li>未缩进的代码。</li>
<li>使用put / get（请参阅第20页的“小心使用进程字典”。）。</li>
<li>无法控制消息队列（请参见第16页的“刷新未知消息”和第18页的“超时”）。</li>
</ul>
<h3>所需文件</h3>
<p>本节描述了设计和维护使用Erlang编程的系统所必需的一些系统级文档。</p>
<h4>10.1 模块描述</h4>
<p>每个模块一章。包含每个模块的描述，以及所有导出的函数，如下所示：</p>
<ul>
<li>函数参数的含义和数据结构</li>
<li>返回值的含义和数据结构。</li>
<li>函数的目的</li>
<li>可能由于显式调用exit / 1而产生的失败和退出信号的可能原因。</li>
</ul>
<p>稍后定义的文档格式：</p>
<h4>10.2 消息描述</h4>
<p>除一个模块内定义的消息之外的所有进程间消息的格式。</p>
<p>稍后定义的文档格式：</p>
<h4>10.3 进程</h4>
<p>系统中所有已注册服务器的描述及其接口和用途。</p>
<p>动态进程及其接口的描述。</p>
<p>稍后定义的文档格式：</p>
<h4>10.4 错误消息</h4>
<p>错误消息的描述</p>
<p>稍后定义的文档格式：</p>

            </div>
        </div>
        </div>
        </div>
    </body>

</html>
