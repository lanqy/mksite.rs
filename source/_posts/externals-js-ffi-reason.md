---
title: 傻瓜式类型安全绑定从 JS 到 Reason
description: 傻瓜式类型安全绑定从 JS 到 Reason
created: 2018/05/25
author: lanqy
---


# 傻瓜式类型安全绑定从 JS 到 Reason。

译自： http://blog.klipse.tech/reason/2017/10/17/externals-js-ffi-reason.html

有时，我们需要能够从我们的 Reason 代码中访问 JS 代码。这是所谓的 Javascript 互操作性的一部分。

更具体地说，这叫做 FFI (外部函数接口)。FFI 是一种机制，用一种编程语言编写的程序可以调用例程或使用另一种编程语言编写的服务。

在 Reason 的背景下，为了访问 JS 代码，我们必须从 JS 到 Reason 构建类型安全的绑定。为此，我们必须编写类型声明。

Reason 的 FFI 非常强大，但这种能力是有代价的。了解它的工作原理有点复杂。

本文的目的是以简单的方式公开 Reason 的 FFI 的主要功能，以帮助您克服语法的困难。

![烧脑](/images/burn-out.jpg)

## 绑定到简单的 JS 函数值

我们来看看一些例子：

以下是我们如何使 `Math.sqrt` 函数可以访问我们的 Reason 代码：

```ocaml
[@bs.val] external sqrt : float => float = "Math.sqrt";
let a = sqrt (2.0);

/* 1.4142135623730951 */
```

当指定的名称与原始名称完全相同时，我们可以将名称留空：

```ocaml
[@bs.val] external encodeURIComponent : string => string = "";
let a = encodeURIComponent("Hello World\n");

/* Hello%20World%0A */
```

## 绑定到 JavaScript 构造函数：bs.new

`bs.new` 用于创建 JavaScript 对象。

```ocaml
type date;
[@bs.new] external create_date : unit => date = "Date";
let date = create_date ();
/* Fri May 25 2018 14:32:19 GMT+0800 (中国标准时间) */
```

## 绑定到方法：bs.send 和 bs.send.pipe

`bs.send` 允许我们调用一个 JS 对象的方法。例如，这是我们如何绑定 `dom.getElementById`

`dom` 是 `DOM` 的抽象类型，`element` 是元素的抽象类型

```ocaml
type dom;
[@bs.val] external dom : dom = "document";
type element;
[@bs.send] external get_by_id : dom => string => element = "getElementById";

let a = get_by_id(dom, "klipse");
```

输出

```javascript
// Generated by BUCKLESCRIPT VERSION 1.9.2, PLEASE EDIT WITH CARE
'use strict';

var a = document.getElementById("klipse");

exports.a = a;
/* a Not a pure module */
```

`bs.send.pipe` 与 `bs.send` 相似，除了第一个参数，即对象，放在最后一个参数的位置，以帮助用户以链式编写：

```ocaml
[@bs.send.pipe : array('a)] external map : ([@bs] ('a => 'b)) => array('b) = "";

let test (arr) =
  arr
  |> map ([@bs] (fun (x) => x + 1))
  |> map ([@bs] (fun (x) => x * 4));

let a = test([|1,2,3|]);

/* 8,12,16 */
```

如果您对 Ocaml / Reason 管道运算符还不熟悉，则这里是经过转换的 js 代码：

```ocaml
[@bs.send.pipe : array('a)] external map : ([@bs] ('a => 'b)) => array('b) = "";

let test (arr) =
  arr
  |> map ([@bs] (fun (x) => x + 1))
  |> map ([@bs] (fun (x) => x * 4));
```

转换成：

```javascript
// Generated by BUCKLESCRIPT VERSION 1.9.2, PLEASE EDIT WITH CARE
'use strict';


function test(arr) {
return arr.map((function (x) {
return x + 1 | 0;
})).map((function (x) {
return (x << 2);
}));
}

exports.test = test;
/* No side effect */
```

> 如果您对回调中的[@bs]属性感兴趣，请参阅[绑定到回调函数（高阶函数）](https://bucklescript.github.io/bucklescript/Manual.html#_binding_to_callbacks_high_order_function)。

绑定到动态密钥访问/设置：`bs.set_index` 和 `bs.get_index`

以下是我们如何对 JavaScript 属性进行动态访问：

```ocaml
type js_array;
[@bs.new] external create : int => js_array = "Int32Array";
[@bs.get_index] external get : js_array => int => int = "";
[@bs.set_index] external set : js_array => int => int => unit = "";

let i32arr = create(3);
set(i32arr, 0, 42);
let a = get(i32arr, 0);

/* 42 */
```

## 绑定到 Getter / Setter：bs.get，bs.set。

该属性有助于获取和设置 JavaScript 对象的属性。

让我们在 javascript klipse 片段中定义一个 javascript 对象：

```javascript
var bob = {"name": "Bob", "age": 32};
```

现在，下面是我们如何创建 setter 和 getter 到这个 javascript 对象（谢谢 @yawaramin，来自 Reason Discord！）：

```ocaml
type person;
[@bs.val] external bob : person = "";
[@bs.get] external get_age : person => int = "age";
[@bs.set] external set_age : (person, int) => unit = "age";

let () = {
  let bobAge = get_age(bob);
  set_age(bob, bobAge + 1)
}

/* 33 */
```
只是为了好玩，看一下如何简单和干净的转换的js代码:

```ocaml
type person;
[@bs.val] external bob : person = "";
[@bs.get] external get_age : person => int = "age";
[@bs.set] external set_age : (person, int) => unit = "age";

let () = {
  let bobAge = get_age(bob);
  set_age(bob, bobAge + 1)
};
```

转成：

```javascript
// Generated by BUCKLESCRIPT VERSION 1.9.2, PLEASE EDIT WITH CARE
'use strict';


var bobAge = bob.age;

bob.age = bobAge + 1 | 0;

/* bobAge Not a pure module */
```

## 拼接调用约定：bs.splice

在 JS 中，有一个函数采用可变参数是很常见的。 BuckleScript 支持类型同质可变参数。我们传递一个数组，而不是传递可变数量的参数：

```ocaml
[@bs.val] [@bs.splice] external max : array(int) => int = "Math.max";

max([|10, 12, 99|]);

/* 99 */
```

## 绑定到来自模块的值：bs.module

我们可以绑定到 js 模块的值：

```ocaml
[@bs.module "x"] external add : (int, int) => int = "add";

let f = add(3, 4);
```

转成：

```javascript
// Generated by BUCKLESCRIPT VERSION 1.9.2, PLEASE EDIT WITH CARE
'use strict';

var X = require("x");

var f = X.add(3, 4);

exports.f = f;
/* f Not a pure module */
```

我们甚至可以提示编译器为模块生成一个更好的名称：

```ocaml
[@bs.module ("x", "coolx")] external add : (int, int) => int = "add";

let f = add(3, 4);
```

转成：

```javascript
// Generated by BUCKLESCRIPT VERSION 1.9.2, PLEASE EDIT WITH CARE
'use strict';

var CoolX = require("x");

var f = CoolX.add(3, 4);

exports.f = f;
/* f Not a pure module */
```

Bucklescript FFI 还有许多其他高级功能。您可以阅读有关优秀的官方 [BuckleScript手册](https://bucklescript.github.io/bucklescript/Manual.html#_ffi)。

注意到使用 FFI，在 `ReasonReact` 项目中访问 React.js 组件非常简单，因为它在[这里](https://reasonml.github.io/reason-react/docs/en/interop.html)已经解释了。
